
                            <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CodeCanvas - Ultimate Ideation Studio</title>
    <meta name="description" content="A self-contained, portable digital sanctuary for creators, developers, and thinkers.">
    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>✏️</text></svg>">
    <style>
        /* --- CSS Variables for Themes --- */
        /* Base Theme (Dark - VS Code Inspired) */
        :root {
            --bg-canvas: #1e1e1e;
            --bg-primary: #252526;
            --bg-secondary: #3c3c3c;
            --bg-tertiary: #2d2d30;
            --bg-hover: #3f3f46;
            --bg-selected: #094771;
            --border-primary: #3c3c3c;
            --border-secondary: #303030;
            --text-primary: #cccccc;
            --text-secondary: #999999;
            --text-tertiary: #ffffff;
            --accent-primary: #4ec9b0; /* Teal */
            --accent-secondary: #3794ff; /* Blue */
            --accent-success: #4ec9b0; /* Teal */
            --accent-warning: #d7ba7d; /* Gold */
            --accent-danger: #f48771; /* Red */
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.5);
            --shadow-md: 0 4px 8px rgba(0, 0, 0, 0.6);
            --shadow-lg: 0 8px 16px rgba(0, 0, 0, 0.7);
            --radius-sm: 4px;
            --radius-md: 6px;
            --radius-lg: 8px;
            --transition-speed: 0.2s;
            --font-ui: "Inter", "Segoe UI", "Roboto", "Helvetica Neue", "Arial", sans-serif;
            --font-code: "Fira Code", "Consolas", "Monaco", "Courier New", monospace;
        }

        /* Light Theme (GitHub Inspired) */
        :root[data-theme="light"] {
            --bg-canvas: #f6f8fa;
            --bg-primary: #ffffff;
            --bg-secondary: #f3f3f3;
            --bg-tertiary: #eaeaea;
            --bg-hover: #e1e4e8;
            --bg-selected: #c8e1ff;
            --border-primary: #e1e4e8;
            --border-secondary: #d1d5da;
            --text-primary: #24292e;
            --text-secondary: #586069;
            --text-tertiary: #000000;
            --accent-primary: #0366d6; /* Blue */
            --accent-secondary: #28a745; /* Green */
            --accent-success: #28a745; /* Green */
            --accent-warning: #dbab09; /* Yellow */
            --accent-danger: #d73a49; /* Red */
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 8px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 8px 16px rgba(0, 0, 0, 0.15);
        }

        /* High Contrast Theme */
        :root[data-theme="high-contrast"] {
            --bg-canvas: #000000;
            --bg-primary: #000000;
            --bg-secondary: #1a1a1a;
            --bg-tertiary: #333333;
            --bg-hover: #4d4d4d;
            --bg-selected: #0066cc;
            --border-primary: #ffffff;
            --border-secondary: #cccccc;
            --text-primary: #ffffff;
            --text-secondary: #cccccc;
            --text-tertiary: #ffffff;
            --accent-primary: #ffff00; /* Yellow */
            --accent-secondary: #00ffff; /* Cyan */
            --accent-success: #00ff00; /* Bright Green */
            --accent-warning: #ff9900; /* Orange */
            --accent-danger: #ff0000; /* Bright Red */
            --shadow-sm: 0 0 0 1px var(--border-primary);
            --shadow-md: 0 0 0 2px var(--border-primary);
            --shadow-lg: 0 0 0 3px var(--border-primary);
            --radius-sm: 0;
            --radius-md: 0;
            --radius-lg: 0;
        }

        /* --- Core Styles --- */
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-ui);
            background-color: var(--bg-canvas);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
            user-select: none;
            font-size: 14px;
            line-height: 1.5;
        }

        a {
            color: var(--accent-secondary);
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }

        /* --- Layout --- */
        .app-container {
            display: grid;
            grid-template-columns: auto 1fr auto;
            grid-template-rows: auto 1fr auto;
            height: 100vh;
            overflow: hidden;
        }

        /* Top Bar */
        .top-bar {
            grid-column: 2 / 3;
            grid-row: 1 / 2;
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border-primary);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            z-index: 100;
            box-shadow: var(--shadow-sm);
        }
        .project-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .project-name {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 200px;
        }
        .project-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        /* Toolbar */
        .toolbar {
            grid-column: 1 / 2;
            grid-row: 1 / 4;
            background: var(--bg-primary);
            border-right: 1px solid var(--border-primary);
            display: flex;
            flex-direction: column;
            padding: 10px 0;
            z-index: 90;
            box-shadow: var(--shadow-sm);
            width: 56px;
        }
        .tool-btn {
            width: 40px;
            height: 40px;
            margin: 4px auto;
            background: var(--bg-secondary);
            border: 1px solid transparent;
            border-radius: var(--radius-sm);
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--transition-speed) ease;
            position: relative;
        }
        .tool-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
            transform: translateY(-1px);
            box-shadow: var(--shadow-sm);
        }
        .tool-btn.active {
            background: var(--accent-primary);
            color: var(--text-tertiary);
            border-color: var(--accent-secondary);
            box-shadow: 0 0 0 2px rgba(78, 201, 176, 0.3);
        }
        .tool-btn svg {
            width: 18px;
            height: 18px;
        }
        .tooltip {
            position: absolute;
            left: 100%;
            margin-left: 10px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            padding: 6px 10px;
            border-radius: var(--radius-sm);
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity var(--transition-speed);
            z-index: 1000;
            box-shadow: var(--shadow-md);
            border: 1px solid var(--border-secondary);
        }
        .tool-btn:hover .tooltip {
            opacity: 1;
        }
        .toolbar-divider {
            height: 1px;
            background: var(--border-primary);
            margin: 8px 6px;
        }

        /* Canvas Container */
        .canvas-container {
            grid-column: 2 / 3;
            grid-row: 2 / 3;
            position: relative;
            background: var(--bg-canvas);
            overflow: hidden;
            outline: none; /* For focus management */
        }
        .canvas {
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
            width: 100%;
            height: 100%;
        }
        .canvas-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image:
                linear-gradient(var(--border-secondary) 1px, transparent 1px),
                linear-gradient(90deg, var(--border-secondary) 1px, transparent 1px);
            background-size: 20px 20px;
            pointer-events: none; /* Grid doesn't interfere with interactions */
        }
        .canvas.no-grid .canvas-grid {
            display: none;
        }

        /* Properties Panel */
        .properties-panel {
            grid-column: 3 / 4;
            grid-row: 1 / 4;
            background: var(--bg-primary);
            border-left: 1px solid var(--border-primary);
            padding: 20px;
            overflow-y: auto;
            z-index: 90;
            transition: transform 0.3s ease;
            box-shadow: var(--shadow-sm);
            width: 260px;
            display: flex;
            flex-direction: column;
        }
        .properties-panel.hidden {
            transform: translateX(100%);
        }
        .properties-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .properties-panel-header h3 {
            font-size: 16px;
            font-weight: 600;
            margin: 0;
        }
        .properties-panel-toggle {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 4px;
            border-radius: var(--radius-sm);
        }
        .properties-panel-toggle:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }
        .property-group {
            margin-bottom: 20px;
        }
        .property-label {
            display: block;
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .property-input {
            width: 100%;
            padding: 8px 10px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-sm);
            color: var(--text-primary);
            font-size: 13px;
            font-family: var(--font-ui);
            transition: all var(--transition-speed) ease;
        }
        .property-input:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 2px rgba(78, 201, 176, 0.2);
        }
        .property-input[type="range"] {
            padding: 4px 0;
        }
        .color-picker-wrapper {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }
        .color-swatch {
            width: 28px;
            height: 28px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            border: 1px solid transparent;
            transition: all var(--transition-speed) ease;
        }
        .color-swatch:hover {
            transform: scale(1.1);
            border-color: var(--text-primary);
        }
        .color-swatch.active {
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 2px var(--bg-primary), 0 0 0 4px var(--accent-primary);
        }

        /* Canvas Elements */
        .canvas-element {
            position: absolute;
            cursor: move;
            user-select: text; /* Allow text selection in text/code elements */
        }
        .canvas-element.selected {
            outline: 2px solid var(--accent-primary);
            outline-offset: 1px;
            z-index: 10; /* Ensure selected element is on top during manipulation */
        }
        .text-element {
            padding: 8px;
            background: transparent;
            border: 1px dashed transparent; /* Invisible border for resizing */
            color: var(--text-primary);
            font-family: var(--font-ui);
            resize: none;
            outline: none;
            min-width: 100px;
            min-height: 30px;
            overflow: hidden;
            border-radius: var(--radius-sm);
        }
        .text-element:focus {
             border-color: var(--accent-primary);
             background: rgba(255, 255, 255, 0.05);
        }
        .code-element {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-md);
            padding: 12px;
            font-family: var(--font-code);
            font-size: 13px;
            white-space: pre;
            overflow: auto;
            min-width: 150px;
            min-height: 80px;
            outline: none;
        }
        .code-element:focus {
            border-color: var(--accent-primary);
        }
        .shape-element {
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: all; /* Ensure shape SVG handles events */
        }
        .shape-element svg {
             pointer-events: all;
        }
        /* Connector Elements */
        .connector-element {
            pointer-events: all; /* Ensure connector SVG handles events */
            cursor: pointer;
        }
        .connector-element.selected {
            filter: drop-shadow(0 0 2px var(--accent-primary));
        }
        .connector-path {
            fill: none;
            stroke: var(--text-primary);
            stroke-width: 2;
            marker-end: url(#arrowhead);
        }
        .connector-label {
            font-family: var(--font-ui);
            font-size: 12px;
            fill: var(--text-primary);
            pointer-events: all; /* Allow interaction with label */
            cursor: text;
        }
        .connector-point {
            fill: rgba(78, 201, 176, 0.5);
            stroke: var(--accent-primary);
            stroke-width: 1;
            cursor: crosshair;
            pointer-events: all;
        }
        .connector-point:hover {
            fill: var(--accent-primary);
            r: 5; /* Slightly larger on hover */
        }
        /* Flowchart Shapes */
        .flowchart-shape {
            cursor: pointer;
        }

        /* --- UI Components --- */
        /* Buttons */
        .btn {
            padding: 6px 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-sm);
            color: var(--text-primary);
            font-size: 13px;
            font-family: var(--font-ui);
            cursor: pointer;
            transition: all var(--transition-speed) ease;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
        }
        .btn:hover {
            background: var(--bg-hover);
            transform: translateY(-1px);
            box-shadow: var(--shadow-sm);
        }
        .btn:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(78, 201, 176, 0.3);
        }
        .btn:active {
            transform: translateY(0);
        }
        .btn-primary {
            background: var(--accent-primary);
            border-color: var(--accent-secondary);
            color: var(--text-tertiary);
        }
        .btn-primary:hover {
            background: color-mix(in srgb, var(--accent-primary) 90%, black);
            border-color: color-mix(in srgb, var(--accent-secondary) 90%, black);
        }
        .btn-danger {
            background: var(--accent-danger);
            border-color: color-mix(in srgb, var(--accent-danger) 80%, black);
            color: var(--text-tertiary);
        }
        .btn-danger:hover {
            background: color-mix(in srgb, var(--accent-danger) 90%, black);
            border-color: color-mix(in srgb, var(--accent-danger) 80%, black);
        }
        .btn-sm {
            padding: 4px 8px;
            font-size: 12px;
        }
        .btn-icon {
            padding: 6px;
        }
        .btn-icon svg {
            width: 16px;
            height: 16px;
        }

        /* Zoom Controls */
        .zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 280px; /* Account for properties panel width */
            display: flex;
            gap: 6px;
            background: var(--bg-primary);
            padding: 6px;
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--border-primary);
            z-index: 80;
        }
        .zoom-btn {
            width: 30px;
            height: 30px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-sm);
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--transition-speed) ease;
        }
        .zoom-btn:hover {
            background: var(--bg-hover);
        }
        .zoom-level {
            min-width: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: var(--text-secondary);
            padding: 0 4px;
        }
        .zoom-input {
            width: 60px;
            padding: 2px 4px;
            font-size: 12px;
            text-align: center;
        }

        /* Modals */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(2px);
        }
        .modal.active {
            display: flex;
        }
        .modal-content {
            background: var(--bg-primary);
            border-radius: var(--radius-md);
            padding: 25px;
            max-width: 90vw;
            width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--border-primary);
            display: flex;
            flex-direction: column;
        }
        .modal-header {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            color: var(--text-primary);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 20px;
            padding: 4px;
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .modal-close:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }
        .modal-body {
            margin-bottom: 20px;
            flex-grow: 1;
        }
        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        /* Project List */
        .project-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-sm);
            background: var(--bg-secondary);
        }
        .project-item {
            padding: 12px 15px;
            border-bottom: 1px solid var(--border-primary);
            cursor: pointer;
            transition: background var(--transition-speed) ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .project-item:hover {
            background: var(--bg-hover);
        }
        .project-item.selected {
            background: var(--bg-selected);
        }
        .project-item:last-child {
            border-bottom: none;
        }
        .project-date {
            font-size: 11px;
            color: var(--text-secondary);
        }
        .project-actions-cell {
            display: flex;
            gap: 5px;
        }
        .project-action-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 2px;
            border-radius: var(--radius-sm);
        }
        .project-action-btn:hover {
            color: var(--accent-danger);
            background: color-mix(in srgb, var(--accent-danger) 20%, transparent);
        }

        /* Floating Action Button */
        .fab {
            position: fixed;
            bottom: 20px;
            left: 76px; /* Toolbar width + margin */
            width: 50px;
            height: 50px;
            background: var(--accent-primary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-tertiary);
            box-shadow: var(--shadow-lg);
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 100;
            border: none;
        }
        .fab:hover {
            transform: scale(1.1) rotate(90deg);
            background: var(--accent-secondary);
            box-shadow: 0 0 15px rgba(55, 148, 255, 0.6);
        }

        /* Notifications */
        .notification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            padding: 12px 20px;
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-lg);
            z-index: 10000;
            animation: fadeInOut 3s ease forwards;
            border: 1px solid var(--border-primary);
            max-width: 90vw;
            word-wrap: break-word;
        }
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateX(-50%) translateY(20px); }
            10% { opacity: 1; transform: translateX(-50%) translateY(0); }
            90% { opacity: 1; transform: translateX(-50%) translateY(0); }
            100% { opacity: 0; transform: translateX(-50%) translateY(20px); }
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        ::-webkit-scrollbar-track {
            background: var(--bg-primary);
            border-radius: var(--radius-sm);
        }
        ::-webkit-scrollbar-thumb {
            background: var(--bg-secondary);
            border-radius: var(--radius-sm);
            border: 2px solid var(--bg-primary);
        }
        ::-webkit-scrollbar-thumb:hover {
            background: var(--bg-hover);
        }
        /* For Firefox */
        * {
            scrollbar-width: thin;
            scrollbar-color: var(--bg-secondary) var(--bg-primary);
        }

        /* --- Embedded PrismJS Theme (Single, Customizable) --- */
        /* Base for all themes */
        pre[class*="language-"] {
            color: var(--text-primary);
            background: var(--bg-secondary);
            border-radius: var(--radius-md);
        }
        code[class*="language-"] {
            color: var(--text-primary);
            background: none;
            font-family: var(--font-code);
            text-shadow: none;
            font-size: 1em;
        }
        .token.comment,
        .token.prolog,
        .token.doctype,
        .token.cdata {
            color: var(--text-secondary);
        }
        .token.punctuation {
            color: var(--text-primary);
        }
        .token.namespace {
            opacity: .7;
        }
        .token.property,
        .token.tag,
        .token.boolean,
        .token.number,
        .token.constant,
        .token.symbol,
        .token.deleted {
            color: var(--accent-danger);
        }
        .token.selector,
        .token.attr-name,
        .token.string,
        .token.char,
        .token.builtin,
        .token.inserted {
            color: var(--accent-success);
        }
        .token.operator,
        .token.entity,
        .token.url,
        .language-css .token.string,
        .style .token.string {
            color: var(--text-primary);
        }
        .token.atrule,
        .token.attr-value,
        .token.keyword {
            color: var(--accent-primary);
        }
        .token.function,
        .token.class-name {
            color: var(--accent-secondary);
        }
        .token.regex,
        .token.important,
        .token.variable {
            color: var(--accent-warning);
        }
        .token.important,
        .token.bold {
            font-weight: bold;
        }
        .token.italic {
            font-style: italic;
        }
        .token.entity {
            cursor: help;
        }

        /* Specific overrides for themes if needed */
        /* Light Theme Overrides */
        :root[data-theme="light"] pre[class*="language-"],
        :root[data-theme="light"] code[class*="language-"] {
            color: var(--text-primary);
            background: var(--bg-secondary);
        }
        :root[data-theme="light"] .token.property,
        :root[data-theme="light"] .token.tag,
        :root[data-theme="light"] .token.boolean,
        :root[data-theme="light"] .token.number,
        :root[data-theme="light"] .token.constant,
        :root[data-theme="light"] .token.symbol,
        :root[data-theme="light"] .token.deleted {
            color: #d73a49; /* GitHub Red */
        }
        :root[data-theme="light"] .token.selector,
        :root[data-theme="light"] .token.attr-name,
        :root[data-theme="light"] .token.string,
        :root[data-theme="light"] .token.char,
        :root[data-theme="light"] .token.builtin,
        :root[data-theme="light"] .token.inserted {
            color: #032f62; /* GitHub Blue */
        }
        :root[data-theme="light"] .token.atrule,
        :root[data-theme="light"] .token.attr-value,
        :root[data-theme="light"] .token.keyword {
            color: #d73a49; /* GitHub Purple */
        }
        :root[data-theme="light"] .token.function,
        :root[data-theme="light"] .token.class-name {
            color: #6f42c1; /* GitHub Purple */
        }

        /* High Contrast Overrides */
        :root[data-theme="high-contrast"] pre[class*="language-"],
        :root[data-theme="high-contrast"] code[class*="language-"] {
            color: var(--text-primary);
            background: var(--bg-secondary);
        }
        :root[data-theme="high-contrast"] .token.comment,
        :root[data-theme="high-contrast"] .token.prolog,
        :root[data-theme="high-contrast"] .token.doctype,
        :root[data-theme="high-contrast"] .token.cdata {
            color: #cccccc;
        }
        :root[data-theme="high-contrast"] .token.punctuation {
            color: var(--text-primary);
        }
        :root[data-theme="high-contrast"] .token.property,
        :root[data-theme="high-contrast"] .token.tag,
        :root[data-theme="high-contrast"] .token.boolean,
        :root[data-theme="high-contrast"] .token.number,
        :root[data-theme="high-contrast"] .token.constant,
        :root[data-theme="high-contrast"] .token.symbol,
        :root[data-theme="high-contrast"] .token.deleted {
            color: var(--accent-danger); /* Bright Red */
        }
        :root[data-theme="high-contrast"] .token.selector,
        :root[data-theme="high-contrast"] .token.attr-name,
        :root[data-theme="high-contrast"] .token.string,
        :root[data-theme="high-contrast"] .token.char,
        :root[data-theme="high-contrast"] .token.builtin,
        :root[data-theme="high-contrast"] .token.inserted {
            color: var(--accent-success); /* Bright Green */
        }
        :root[data-theme="high-contrast"] .token.operator,
        :root[data-theme="high-contrast"] .token.entity,
        :root[data-theme="high-contrast"] .token.url,
        :root[data-theme="high-contrast"] .language-css .token.string,
        :root[data-theme="high-contrast"] .style .token.string {
            color: var(--text-primary);
        }
        :root[data-theme="high-contrast"] .token.atrule,
        :root[data-theme="high-contrast"] .token.attr-value,
        :root[data-theme="high-contrast"] .token.keyword {
            color: var(--accent-primary); /* Yellow */
        }
        :root[data-theme="high-contrast"] .token.function,
        :root[data-theme="high-contrast"] .token.class-name {
            color: var(--accent-secondary); /* Cyan */
        }
        :root[data-theme="high-contrast"] .token.regex,
        :root[data-theme="high-contrast"] .token.important,
        :root[data-theme="high-contrast"] .token.variable {
            color: var(--accent-warning); /* Orange */
        }
    </style>
</head>
<body>
    <div class="app-container" tabindex="-1" id="appContainer">
        <!-- Top Bar -->
        <div class="top-bar">
            <div class="project-info">
                <span class="project-name" id="projectName">Untitled Project</span>
            </div>
            <div class="project-actions">
                <button class="btn" id="newProjectBtn">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
                    New (N)
                </button>
                <button class="btn" id="openProjectBtn">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2z"></path></svg>
                    Open (O)
                </button>
                <button class="btn" id="saveProjectBtn">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21H5a2 2 0 01-2-2V5a2 2 0 012-2h11l5 5v11a2 2 0 01-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg>
                    Save (Ctrl+S)
                </button>
                <button class="btn btn-primary" id="exportBtn">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                    Export (Ctrl+Shift+E)
                </button>
                <button class="btn" id="importBtn">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>
                    Import
                </button>
                <button class="btn" id="themeToggleBtn">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path></svg>
                    Theme
                </button>
            </div>
        </div>

        <!-- Toolbar -->
        <div class="toolbar">
            <button class="tool-btn active" data-tool="select" title="Select Tool (V)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"></path></svg>
                <span class="tooltip">Select (V)</span>
            </button>
            <button class="tool-btn" data-tool="brush" title="Brush Tool (B)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2L2 7v10c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V7l-10-5z"></path></svg>
                <span class="tooltip">Brush (B)</span>
            </button>
            <button class="tool-btn" data-tool="eraser" title="Eraser Tool (E)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 21H9l-7-7a2 2 0 010-2.83l10-10a2 2 0 012.83 0l7 7a2 2 0 010 2.83L13 21"></path></svg>
                <span class="tooltip">Eraser (E)</span>
            </button>
            <button class="tool-btn" data-tool="text" title="Text Tool (T)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M13 4h-2v16h2M6 20h12M6 4h12"></path></svg>
                <span class="tooltip">Text (T)</span>
            </button>
            <button class="tool-btn" data-tool="shape" title="Shape Tool (S)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"></rect></svg>
                <span class="tooltip">Shape (S)</span>
            </button>
            <button class="tool-btn" data-tool="connector" title="Connector Tool (C)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 11L3 17l6 6 6-6-6-6zM21 3l-6 6 6 6"></path></svg>
                <span class="tooltip">Connector (C)</span>
            </button>
            <button class="tool-btn" data-tool="code" title="Code Snippet">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline></svg>
                <span class="tooltip">Code Snippet</span>
            </button>
            <div class="toolbar-divider"></div>
            <button class="tool-btn" id="undoBtn" title="Undo (Ctrl+Z)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 7v6h6"></path><path d="M21 17a9 9 0 00-9-9 9 9 0 00-6 2.3L3 13"></path></svg>
                <span class="tooltip">Undo (Ctrl+Z)</span>
            </button>
            <button class="tool-btn" id="redoBtn" title="Redo (Ctrl+Y)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 7v6h-6"></path><path d="M3 17a9 9 0 019-9 9 9 0 016 2.3L21 13"></path></svg>
                <span class="tooltip">Redo (Ctrl+Y)</span>
            </button>
            <button class="tool-btn" id="gridToggle" title="Toggle Grid">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="6" height="6"></rect><rect x="15" y="3" width="6" height="6"></rect><rect x="3" y="15" width="6" height="6"></rect><rect x="15" y="15" width="6" height="6"></rect></svg>
                <span class="tooltip">Toggle Grid</span>
            </button>
        </div>

        <!-- Canvas Container -->
        <div class="canvas-container" id="canvasContainer" tabindex="0"> <!-- For key events -->
            <div class="canvas" id="canvas">
                <div class="canvas-grid"></div>
                <!-- SVG Definitions for Markers -->
                <svg style="position: absolute; width: 0; height: 0;">
                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="7"
                        refX="10" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="var(--text-primary)"/>
                        </marker>
                    </defs>
                </svg>
            </div>
        </div>

        <!-- Properties Panel -->
        <div class="properties-panel" id="propertiesPanel">
            <div class="properties-panel-header">
                <h3>Properties</h3>
                <button class="properties-panel-toggle" id="togglePropertiesPanel" aria-label="Close properties panel">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </button>
            </div>
            <!-- Brush Properties -->
            <div id="brushProperties" style="display: none;">
                <div class="property-group">
                    <label class="property-label">Brush Color</label>
                    <div class="color-picker-wrapper">
                        <div class="color-swatch active" style="background: #ffffff;" data-color="#ffffff"></div>
                        <div class="color-swatch" style="background: #f48771;" data-color="#f48771"></div>
                        <div class="color-swatch" style="background: #4ec9b0;" data-color="#4ec9b0"></div>
                        <div class="color-swatch" style="background: #3794ff;" data-color="#3794ff"></div>
                        <div class="color-swatch" style="background: #d7ba7d;" data-color="#d7ba7d"></div>
                        <div class="color-swatch" style="background: #c586c0;" data-color="#c586c0"></div>
                        <div class="color-swatch" style="background: #4ec9b0;" data-color="#4ec9b0"></div>
                        <div class="color-swatch" style="background: #9cdcfe;" data-color="#9cdcfe"></div>
                    </div>
                </div>
                <div class="property-group">
                    <label class="property-label">Brush Size</label>
                    <input type="range" class="property-input" id="brushSize" min="1" max="20" value="3">
                    <div style="text-align: center; margin-top: 5px; font-size: 12px; color: var(--text-secondary);">
                        <span id="brushSizeValue">3</span>px
                    </div>
                </div>
                <div class="property-group">
                    <label class="property-label">Opacity</label>
                    <input type="range" class="property-input" id="brushOpacity" min="0" max="100" value="100">
                    <div style="text-align: center; margin-top: 5px; font-size: 12px; color: var(--text-secondary);">
                        <span id="brushOpacityValue">100</span>%
                    </div>
                </div>
            </div>
            <!-- Text Properties -->
            <div id="textProperties" style="display: none;">
                <div class="property-group">
                    <label class="property-label">Font Family</label>
                    <select class="property-input" id="fontFamily">
                        <option value="Inter, Segoe UI, Roboto, Helvetica, Arial, sans-serif">Inter</option>
                        <option value="Arial, Helvetica, sans-serif">Arial</option>
                        <option value="Georgia, serif">Georgia</option>
                        <option value="Times New Roman, Times, serif">Times New Roman</option>
                        <option value="Fira Code, Consolas, Monaco, monospace">Fira Code</option>
                        <option value="Verdana, sans-serif">Verdana</option>
                    </select>
                </div>
                <div class="property-group">
                    <label class="property-label">Font Size</label>
                    <input type="number" class="property-input" id="fontSize" value="16" min="8" max="72">
                </div>
                <div class="property-group">
                    <label class="property-label">Text Color</label>
                    <input type="color" class="property-input" id="textColor" value="#cccccc">
                </div>
                <div class="property-group">
                    <label class="property-label">Formatting</label>
                    <div style="display: flex; gap: 6px;">
                        <button class="btn btn-sm" id="boldBtn" style="font-weight: bold;">B</button>
                        <button class="btn btn-sm" id="italicBtn" style="font-style: italic;">I</button>
                        <button class="btn btn-sm" id="underlineBtn" style="text-decoration: underline;">U</button>
                    </div>
                </div>
                 <div class="property-group">
                    <label class="property-label">Alignment</label>
                    <div style="display: flex; gap: 6px;">
                        <button class="btn btn-sm" id="alignLeftBtn" title="Align Left">&#8676;</button>
                        <button class="btn btn-sm" id="alignCenterBtn" title="Align Center">&#8677;&#8676;</button>
                        <button class="btn btn-sm" id="alignRightBtn" title="Align Right">&#8677;</button>
                    </div>
                </div>
            </div>
            <!-- Shape Properties -->
            <div id="shapeProperties" style="display: none;">
                <div class="property-group">
                    <label class="property-label">Shape Type</label>
                    <select class="property-input" id="shapeType">
                        <option value="process">Process</option>
                        <option value="decision">Decision</option>
                        <option value="terminator">Terminator</option>
                        <option value="data">Data</option>
                        <option value="rectangle">Rectangle</option>
                        <option value="circle">Circle</option>
                        <option value="triangle">Triangle</option>
                        <option value="diamond">Diamond</option>
                        <option value="arrow">Arrow</option>
                        <option value="cloud">Cloud</option>
                        <option value="sticky">Sticky Note</option>
                    </select>
                </div>
                <div class="property-group">
                    <label class="property-label">Fill Color</label>
                    <input type="color" class="property-input" id="shapeFillColor" value="#4ec9b0">
                </div>
                <div class="property-group">
                    <label class="property-label">Stroke Color</label>
                    <input type="color" class="property-input" id="shapeStrokeColor" value="#ffffff">
                </div>
                <div class="property-group">
                    <label class="property-label">Stroke Width</label>
                    <input type="range" class="property-input" id="shapeStrokeWidth" min="0" max="10" value="2">
                </div>
                 <div class="property-group">
                    <label class="property-label">Width</label>
                    <input type="number" class="property-input" id="shapeWidth" value="100" min="20" max="500">
                </div>
                <div class="property-group">
                    <label class="property-label">Height</label>
                    <input type="number" class="property-input" id="shapeHeight" value="60" min="20" max="500">
                </div>
            </div>
            <!-- Connector Properties -->
            <div id="connectorProperties" style="display: none;">
                 <div class="property-group">
                    <label class="property-label">Stroke Color</label>
                    <input type="color" class="property-input" id="connectorStrokeColor" value="#cccccc">
                </div>
                <div class="property-group">
                    <label class="property-label">Stroke Width</label>
                    <input type="range" class="property-input" id="connectorStrokeWidth" min="1" max="10" value="2">
                </div>
                 <div class="property-group">
                    <label class="property-label">Arrowheads</label>
                    <select class="property-input" id="connectorArrowheads">
                        <option value="end">End</option>
                        <option value="start">Start</option>
                        <option value="both">Both</option>
                        <option value="none">None</option>
                    </select>
                </div>
            </div>
            <!-- Code Properties -->
            <div id="codeProperties" style="display: none;">
                <div class="property-group">
                    <label class="property-label">Language</label>
                    <select class="property-input" id="codeLanguage">
                        <option value="javascript">JavaScript</option>
                        <option value="python">Python</option>
                        <option value="html">HTML</option>
                        <option value="css">CSS</option>
                        <option value="java">Java</option>
                        <option value="cpp">C++</option>
                        <option value="typescript">TypeScript</option>
                        <option value="rust">Rust</option>
                        <option value="go">Go</option>
                        <option value="ruby">Ruby</option>
                        <option value="php">PHP</option>
                        <option value="swift">Swift</option>
                    </select>
                </div>
                 <div class="property-group">
                    <button class="btn" id="copyCodeBtn">Copy Code</button>
                </div>
            </div>
            <!-- General Element Properties -->
            <div id="elementProperties" style="display: none;">
                <div class="property-group">
                    <label class="property-label">Actions</label>
                    <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                        <button class="btn btn-sm" id="bringToFrontBtn">Bring Front</button>
                        <button class="btn btn-sm" id="sendToBackBtn">Send Back</button>
                        <button class="btn btn-sm" id="duplicateElementBtn">Duplicate</button>
                        <button class="btn btn-sm" id="lockElementBtn">Lock</button>
                        <button class="btn btn-sm btn-danger" id="deleteElementBtn">Delete</button>
                    </div>
                </div>
                 <div class="property-group">
                    <label class="property-label">Position</label>
                    <div style="display: flex; gap: 6px;">
                        <input type="number" class="property-input" id="elementX" placeholder="X" style="flex: 1;">
                        <input type="number" class="property-input" id="elementY" placeholder="Y" style="flex: 1;">
                    </div>
                </div>
                 <div class="property-group">
                    <label class="property-label">Size</label>
                    <div style="display: flex; gap: 6px;">
                        <input type="number" class="property-input" id="elementWidth" placeholder="W" style="flex: 1;">
                        <input type="number" class="property-input" id="elementHeight" placeholder="H" style="flex: 1;">
                    </div>
                </div>
                 <div class="property-group">
                    <button class="btn" id="groupElementsBtn">Group Selected</button>
                </div>
            </div>
        </div>

        <!-- Zoom Controls -->
        <div class="zoom-controls">
            <button class="zoom-btn" id="zoomOut" title="Zoom Out">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="12" x2="19" y2="12"></line></svg>
            </button>
            <input type="text" class="zoom-input property-input" id="zoomLevelInput" value="100%" readonly>
            <button class="zoom-btn" id="zoomIn" title="Zoom In">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
            </button>
            <button class="zoom-btn" id="zoomReset" title="Reset Zoom">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"></circle><path d="M21 21l-4.35-4.35"></path></svg>
            </button>
            <button class="zoom-btn" id="zoomFit" title="Fit to Screen">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="9" y1="21" x2="9" y2="9"></line></svg>
            </button>
        </div>

        <!-- Floating Action Button -->
        <button class="fab" id="fabMenu" aria-label="Quick actions">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
        </button>
    </div>

    <!-- Modals -->
    <!-- Project Manager Modal -->
    <div class="modal" id="projectModal">
        <div class="modal-content">
            <div class="modal-header">
                Project Manager
                <button class="modal-close" aria-label="Close">&times;</button>
            </div>
            <div class="modal-body">
                <div class="project-list" id="projectList"></div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="cancelProjectBtn">Cancel</button>
                <button class="btn btn-primary" id="loadProjectBtn">Load Project</button>
            </div>
        </div>
    </div>
    <!-- New Project Modal -->
    <div class="modal" id="newProjectModal">
        <div class="modal-content">
             <div class="modal-header">
                Create New Project
                <button class="modal-close" aria-label="Close">&times;</button>
            </div>
            <div class="modal-body">
                <div class="property-group">
                    <label class="property-label">Project Name</label>
                    <input type="text" class="property-input" id="newProjectName" placeholder="Enter project name...">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="cancelNewProjectBtn">Cancel</button>
                <button class="btn btn-primary" id="createProjectBtn">Create</button>
            </div>
        </div>
    </div>
    <!-- Settings Modal -->
    <div class="modal" id="settingsModal">
        <div class="modal-content">
             <div class="modal-header">
                Settings
                <button class="modal-close" aria-label="Close">&times;</button>
            </div>
            <div class="modal-body">
                <div class="property-group">
                    <label class="property-label">Theme</label>
                    <select class="property-input" id="settingsTheme">
                        <option value="dark">Dark (VS Code)</option>
                        <option value="light">Light (GitHub)</option>
                        <option value="high-contrast">High Contrast</option>
                    </select>
                </div>
                <div class="property-group">
                    <label class="property-label">Grid Spacing</label>
                    <input type="number" class="property-input" id="settingsGridSpacing" value="20" min="10" max="100">
                </div>
                 <div class="property-group">
                    <label class="property-label">Snap to Grid</label>
                    <input type="checkbox" id="settingsSnapToGrid" class="property-input">
                </div>
                 <div class="property-group">
                    <label class="property-label">Autosave Interval (seconds)</label>
                    <input type="number" class="property-input" id="settingsAutosaveInterval" value="30" min="5" max="300">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="cancelSettingsBtn">Cancel</button>
                <button class="btn btn-primary" id="saveSettingsBtn">Save</button>
            </div>
        </div>
    </div>

    <!-- Embedded PrismJS Core and Languages -->
    <script>
    // PrismJS 1.29.0 - Modified to be theme-aware
    var _self = "undefined" != typeof window ? window : "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope ? self : {}, Prism = function(e) {
    var n = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i, t = 0, r = {}, a = {
        manual: e.Prism && e.Prism.manual,
        disableWorkerMessageHandler: e.Prism && e.Prism.disableWorkerMessageHandler,
        util: {
            encode: function e(n) {
                return n instanceof i ? new i(n.type, e(n.content), n.alias) : Array.isArray(n) ? n.map(e) : n.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
            },
            type: function(e) {
                return Object.prototype.toString.call(e).slice(8, -1);
            },
            objId: function(e) {
                return e.__id || Object.defineProperty(e, "__id", {
                    value: ++t
                }), e.__id;
            },
            clone: function e(n, t) {
                var i, l;
                switch (t = t || {}, a.util.type(n)) {
                  case "Object":
                    if (l = a.util.objId(n), t[l]) return t[l];
                    for (var s in i = {}, t[l] = i, n) n.hasOwnProperty(s) && (i[s] = e(n[s], t));
                    return i;

                  case "Array":
                    return l = a.util.objId(n), t[l] ? t[l] : (i = [], t[l] = i, n.forEach((function(n, r) {
                        i[r] = e(n, t);
                    })), i);

                  default:
                    return n;
                }
            },
            getLanguage: function(e) {
                for (;e && !n.test(e.className); ) e = e.parentElement;
                return e ? (e.className.match(n) || [ , "none" ])[1].toLowerCase() : "none";
            },
            currentScript: function() {
                if ("undefined" == typeof document) return null;
                if ("currentScript" in document) return document.currentScript;
                try {
                    throw new Error();
                } catch (e) {
                    var n = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(e.stack) || [])[1];
                    if (n) {
                        var t = document.getElementsByTagName("script");
                        for (var r in t) if (t[r].src == n) return t[r];
                    }
                    return null;
                }
            },
            isActive: function(e, n, t) {
                for (var r = "no-" + n; e; ) {
                    var a = e.classList;
                    if (a.contains(n)) return !0;
                    if (a.contains(r)) return !1;
                    e = e.parentElement;
                }
                return !!t;
            }
        },
        languages: {
            plain: r,
            plaintext: r,
            text: r,
            txt: r,
            extend: function(e, n) {
                var t = a.util.clone(a.languages[e]);
                for (var r in n) t[r] = n[r];
                return t;
            },
            insertBefore: function(e, n, t, r) {
                var i = (r = r || a.languages)[e], l = {};
                for (var s in i) if (i.hasOwnProperty(s)) {
                    if (s == n) for (var o in t) t.hasOwnProperty(o) && (l[o] = t[o]);
                    t.hasOwnProperty(s) || (l[s] = i[s]);
                }
                var u = r[e];
                return r[e] = l, a.languages.DFS(a.languages, (function(n, t) {
                    t === u && n != e && (this[n] = l);
                })), l;
            },
            DFS: function e(n, t, r, i) {
                i = i || {};
                var l = a.util.objId;
                for (var s in n) if (n.hasOwnProperty(s)) {
                    t.call(n, s, n[s], r || s);
                    var o = n[s], u = a.util.type(o);
                    "Object" !== u || i[l(o)] ? "Array" !== u || i[l(o)] || (i[l(o)] = !0, e(o, t, s, i)) : (i[l(o)] = !0,
                    e(o, t, null, i));
                }
            }
        },
        plugins: {},
        highlightAll: function(e, n) {
            a.highlightAllUnder(document, e, n);
        },
        highlightAllUnder: function(e, n, t) {
            var r = {
                callback: t,
                container: e,
                selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
            };
            a.hooks.run("before-highlightall", r), r.elements = Array.prototype.slice.apply(r.container.querySelectorAll(r.selector)),
            a.hooks.run("before-all-elements-highlight", r);
            for (var i, l = 0; i = r.elements[l++]; ) a.highlightElement(i, !0 === n, r.callback);
        },
        highlightElement: function(n, t, r) {
            var i = a.util.getLanguage(n), l = a.languages[i];
            a.util.setLanguage(n, i);
            var s = n.parentElement;
            s && "pre" === s.nodeName.toLowerCase() && a.util.setLanguage(s, i);
            var o = {
                element: n,
                language: i,
                grammar: l,
                code: n.textContent || ""
            };
            function u(e) {
                o.highlightedCode = e, a.hooks.run("before-insert", o), o.element.innerHTML = o.highlightedCode,
                a.hooks.run("after-highlight", o), a.hooks.run("complete", o), r && r.call(o.element);
            }
            if (a.hooks.run("before-sanity-check", o), (s = o.element.parentElement) && "pre" === s.nodeName.toLowerCase() && !s.hasAttribute("tabindex") && s.setAttribute("tabindex", "0"),
            !o.code) return a.hooks.run("complete", o), void (r && r.call(o.element));
            if (a.hooks.run("before-highlight", o), o.grammar) if (t && e.Worker) {
                var c = new Worker(a.filename);
                c.onmessage = function(e) {
                    u(e.data);
                }, c.postMessage(JSON.stringify({
                    language: o.language,
                    code: o.code,
                    immediateClose: !0
                }));
            } else u(a.highlight(o.code, o.grammar, o.language)); else u(a.util.encode(o.code));
        },
        highlight: function(e, n, t) {
            var r = {
                code: e,
                grammar: n,
                language: t
            };
            if (a.hooks.run("before-tokenize", r), !r.grammar) throw new Error('The language "' + r.language + '" has no grammar.');
            return r.tokens = a.tokenize(r.code, r.grammar), a.hooks.run("after-tokenize", r),
            i.stringify(a.util.encode(r.tokens), r.language);
        },
        tokenize: function(e, n) {
            var t = n.rest;
            if (t) {
                for (var r in t) n[r] = t[r];
                delete n.rest;
            }
            var a = new s();
            return u(a, a.head, e), o(e, a, n, a.head, 0), function(e) {
                for (var n = [], t = e.head.next; t !== e.tail; ) n.push(t.value), t = t.next;
                return n;
            }(a);
        },
        hooks: {
            all: {},
            add: function(e, n) {
                var t = a.hooks.all;
                t[e] = t[e] || [], t[e].push(n);
            },
            run: function(e, n) {
                var t = a.hooks.all[e];
                if (t && t.length) for (var r, i = 0; r = t[i++]; ) r(n);
            }
        },
        Token: i
    };
    function i(e, n, t, r) {
        this.type = e, this.content = n, this.alias = t, this.length = 0 | (r || "").length;
    }
    function l(e, n, t, r) {
        e.lastIndex = n;
        var a = e.exec(t);
        if (a && r && a[1]) {
            var i = a[1].length;
            a.index += i, a[0] = a[0].slice(i);
        }
        return a;
    }
    function s() {
        var e = {
            value: null,
            prev: null,
            next: null
        }, n = {
            value: null,
            prev: e,
            next: null
        };
        e.next = n, this.head = e, this.tail = n, this.length = 0;
    }
    function o(e, n, t, r, s, g) {
        for (var f in t) if (t.hasOwnProperty(f) && t[f]) {
            var h = t[f];
            h = Array.isArray(h) ? h : [h];
            for (var d = 0; d < h.length; ++d) {
                if (g && g.cause == f + "," + d) continue;
                var v = h[d], p = v.inside, m = !!v.lookbehind, y = !!v.greedy, k = v.alias;
                if (y && !v.pattern.global) {
                    var x = v.pattern.toString().match(/[imsuy]*$/)[0];
                    v.pattern = RegExp(v.pattern.source, x + "g");
                }
                for (var b = v.pattern || v, w = r.next, A = s; w !== n.tail && !(r.length > n.length); ) {
                    var E = w.value;
                    if (n.length > e.length) return;
                    if (!(E instanceof i)) {
                        var P, L = 1;
                        if (y) {
                            if (!(P = l(b, A, e, m)) || P.index >= e.length) break;
                            var S = P.index, O = P.index + P[0].length, j = A;
                            for (A += E.length; S >= A; ) j = (w = w.next).value, A += j.length;
                            if (A -= j.length, w.value instanceof i) continue;
                            for (var C = w; C !== n.tail && (A < O || "string" == typeof C.value); ) C = C.next;
                            L = n.length, u(n, w, C), w = n.tail;
                        } else if (!(P = l(b, 0, E, m))) continue;
                        var S = P.index, N = P[0], _ = E.slice(0, S), M = E.slice(S + N.length), W = A + E.length;
                        _( && (w.prev.next = new function(e, n) {
                            for (var t = n ? n.value : e.value; t instanceof i && "comment" !== t.type && "cdata" !== t.type; ) n ? (t = t.content).content && (t = t.content) : (t = t.content).content && (t = t.content);
                            return "string" == typeof t ? new i("comment", t) : t;
                        }(_, w.prev), w.prev = w.prev.next), M && (w.next = new function(e, n) {
                            for (var t = n ? n.value : e.value; t instanceof i && "comment" !== t.type && "cdata" !== t.type; ) n ? (t = t.content).content && (t = t.content) : (t = t.content).content && (t = t.content);
                            return "string" == typeof t ? new i("cdata", t) : t;
                        }(M, w), w.next.prev = w.next), L = 1;
                        var z = new i(f, p ? a.tokenize(N, p) : N, k, N);
                        if (w.prev.next = z, w.prev = z, N && z.length++, n.length -= L) {
                            var I = n.length;
                            for (o(e, n, t, w.prev, A, {
                                cause: f + "," + d,
                                reach: I
                            }); L > 0; ) w = w.next, L--;
                            if (n.length > I) {
                                var T = n.length - I;
                                for (r.length += T, L = T; L > 0; ) w = w.prev, L--;
                            }
                        }
                    }
                    w = w.next;
                }
            }
        }
    }
    function u(e, n, t) {
        var r, a, i = n.prev, l = t.next;
        i && i.next == l && (a = i).next = t, (r = n).prev = t.prev, t.prev = r, r.next = t,
        e.length--, u(e, n, t), e.length++;
    }
    if (e.Prism = a, i.stringify = function e(n, t) {
        if ("string" == typeof n) return n;
        if (Array.isArray(n)) {
            var r = "";
            return n.forEach((function(n) {
                r += e(n, t);
            })), r;
        }
        var i = {
            type: n.type,
            content: e(n.content, t),
            tag: "span",
            classes: [ "token", n.type ],
            attributes: {},
            language: t
        }, l = n.alias;
        l && (Array.isArray(l) ? Array.prototype.push.apply(i.classes, l) : i.classes.push(l)),
        a.hooks.run("wrap", i);
        var s = "";
        for (var o in i.attributes) s += " " + o + '="' + (i.attributes[o] || "").replace(/"/g, "&quot;") + '"';
        return "<" + i.tag + ' class="' + i.classes.join(" ") + '"' + s + ">" + i.content + "</" + i.tag + ">";
    }, !e.document) return e.addEventListener ? (a.disableWorkerMessageHandler || e.addEventListener("message", (function(n) {
        var t = JSON.parse(n.data), r = t.language, i = t.code, l = t.immediateClose;
        e.postMessage(a.highlight(i, a.languages[r], r)), l && e.close();
    }), !1), a) : a;
    var c = a.util.currentScript();
    function g() {
        a.manual || a.highlightAll();
    }
    return c && (a.filename = c.src, c.hasAttribute("data-manual") && (a.manual = !0)),
    a.manual || ("loading" === document.readyState ? document.addEventListener("DOMContentLoaded", g) : window.requestAnimationFrame ? window.requestAnimationFrame(g) : window.setTimeout(g, 16)),
    a;
}(_self);
"undefined" != typeof module && module.exports && (module.exports = Prism), "undefined" != typeof global && (global.Prism = Prism);
Prism.languages.markup = {
    comment: {
        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
        greedy: !0
    },
    prolog: {
        pattern: /<\?[\s\S]+?\?>/,
        greedy: !0
    },
    doctype: {
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: !0,
        inside: {
            "internal-subset": {
                pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
                lookbehind: !0,
                greedy: !0,
                inside: null
            },
            string: {
                pattern: /"[^"]*"|'[^']*'/,
                greedy: !0
            },
            punctuation: /^<!|>$|[[\]]/,
            "doctype-tag": /^DOCTYPE/i,
            name: /[^\s<>'"]+/
        }
    },
    c {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        greedy: !0
    },
    tag: {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: !0,
        inside: {
            tag: {
                pattern: /^<\/?[^\s>\/]+/,
                inside: {
                    punctuation: /^<\/?/,
                    namespace: /^[^\s>\/:]+:/
                }
            },
            "special-attr": [],
            "attr-value": {
                pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
                inside: {
                    punctuation: [{
                        pattern: /^=/,
                        alias: "attr-equals"
                    }, {
                        pattern: /^(\s*)["']|["']$/,
                        lookbehind: !0
                    }]
                }
            },
            punctuation: /\/?>/,
            "attr-name": {
                pattern: /[^\s>\/]+/,
                inside: {
                    namespace: /^[^\s>\/:]+:/
                }
            }
        }
    },
    entity: [ {
        pattern: /&[\da-z]{1,8};/i,
        alias: "named-entity"
    }, /&#x?[\da-f]{1,8};/i ]
}, Prism.languages.markup.tag.inside["attr-value"].inside.entity = Prism.languages.markup.entity,
Prism.languages.markup.doctype.inside["internal-subset"].inside = Prism.languages.markup,
Prism.hooks.add("wrap", (function(e) {
    "entity" === e.type && (e.attributes.title = e.content.replace(/&amp;/, "&"));
})), Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
    value: function(e, n) {
        var t = {};
        t["language-" + n] = {
            pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
            lookbehind: !0,
            inside: Prism.languages[n]
        }, t.cdata = /^<!\[CDATA\[|\]\]>$/i;
        var r = {
            "included-cdata": {
                pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
                inside: t
            }
        };
        r["language-" + n] = {
            pattern: /[\s\S]+/,
            inside: Prism.languages[n]
        };
        var a = {};
        a[e] = {
            pattern: RegExp("(<__[^>]*>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[\\s\\S])*?(?=</__>)".replace(/__/g, (function() {
                return e;
            })), "i"),
            lookbehind: !0,
            greedy: !0,
            inside: r
        }, Prism.languages.insertBefore("markup", "cdata", a);
    }
}), Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
    value: function(e, n) {
        Prism.languages.markup.tag.inside["special-attr"].push({
            pattern: RegExp("(^|[\"'\\s])(?:" + e + ")\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))", "i"),
            lookbehind: !0,
            inside: {
                "attr-name": /^[^\s=]+/,
                "attr-value": {
                    pattern: /=[\s\S]+/,
                    inside: {
                        value: {
                            pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                            lookbehind: !0,
                            alias: [ n, "language-" + n ],
                            inside: Prism.languages[n]
                        },
                        punctuation: [{
                            pattern: /^=/,
                            alias: "attr-equals"
                        }, /"|'/]
                    }
                }
            }
        });
    }
}), Prism.languages.html = Prism.languages.markup, Prism.languages.mathml = Prism.languages.markup,
Prism.languages.svg = Prism.languages.markup, Prism.languages.xml = Prism.languages.extend("markup", {}),
Prism.languages.ssml = Prism.languages.xml, Prism.languages.atom = Prism.languages.xml,
Prism.languages.rss = Prism.languages.xml;
Prism.languages.css = {
    comment: /\/\*[\s\S]*?\*\//,
    atrule: {
        pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
        inside: {
            rule: /^@[\w-]+/,
            "selector-function-argument": {
                pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
                lookbehind: !0,
                alias: "selector"
            },
            keyword: {
                pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
                lookbehind: !0
            }
        }
    },
    url: {
        pattern: RegExp("\\burl\\((?:[^\\\\r\\n()\"']|\\\\[\\s\\S]|(?:" + "(?:https?|ftp|file):)?//[^\\s\"'()]+(?:\\([^\\s\"'()]+\\)|[^\\s\"'()])" + "|\"(?:\\\\[^\\n\"\\\\r]|[^\\n\"\\\\\"])*\"|'(?:\\\\[^\\n'\\\\r]|[^\\n'\\\\'])*')\\)", "i"),
        greedy: !0,
        inside: {
            function: /^url/i,
            punctuation: /^\(|\)$/,
            string: {
                pattern: RegExp("^\"(?:\\\\[^\\n\"\\\\r]|[^\\n\"\\\\\"])*\"$|^'(?:\\\\[^\\n'\\\\r]|[^\\n'\\\\'])*'$"),
                inside: {
                    escape: /\\(?:\r\n|[\s\S])/
                }
            }
        }
    },
    selector: {
        pattern: RegExp("(^|[{}\\s])[^{}\\s](?:[^{};\"'\\s]|\\s+(?![\\s{])|\"(?:\\\\[^\\n\"\\\\r]|[^\\n\"\\\\\"])*\"|'(?:\\\\[^\\n'\\\\r]|[^\\n'\\\\'])*')*?(?=\\s*\\{)"),
        lookbehind: !0
    },
    string: {
        pattern: /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
    },
    property: {
        pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
        lookbehind: !0
    },
    important: /!important\b/i,
    function: {
        pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
        lookbehind: !0
    },
    punctuation: /[(){};:,]/
}, Prism.languages.css.atrule.inside.rest = Prism.languages.css;
var e = Prism.languages.markup;
e && (e.tag.addInlined("style", "css"), e.tag.addAttribute("style", "css"));
Prism.languages.clike = {
    comment: [{
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: !0,
        greedy: !0
    }, {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
    }],
    string: {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
    },
    "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: !0,
        inside: {
            punctuation: /[.\\]/
        }
    },
    keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    boolean: /\b(?:false|true)\b/,
    function: /\b\w+(?=\()/,
    number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    punctuation: /[{}[\];(),.:]/
};
Prism.languages.javascript = Prism.languages.extend("clike", {
    "class-name": [Prism.languages.clike["class-name"], {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
        lookbehind: !0
    }],
    keyword: [{
        pattern: /((?:^|\})\s*)catch\b/,
        lookbehind: !0
    }, {
        pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
        lookbehind: !0
    }],
    function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    number: {
        pattern: RegExp("(^|[^\\w$])(?:NaN|Infinity|0[bB][01]+(?:_[01]+)*n?|0[oO][0-7]+(?:_[0-7]+)*n?|0[xX][\\dA-Fa-f]+(?:_[\\dA-Fa-f]+)*n?|\\d+(?:_\\d+)*n|(?:\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\.\\d+(?:_\\d+)*)(?:[Ee][+-]?\\d+(?:_\\d+)*)?)(?![\\w$])"),
        lookbehind: !0
    },
    operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
}), Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/,
Prism.languages.insertBefore("javascript", "keyword", {
    regex: {
        pattern: RegExp("((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s]|\\b(?:return|yield))\\s*)/(?:(?:\\[(?:[^\\]\\\\\r\n]|\\\\.)*\\]|\\\\.|[^/\\\\\\[\r\n])+/[dgimyus]{0,7}|(?:\\[(?:[^[\\]\\\\\r\n]|\\\\.|\\[(?:[^[\\]\\\\\r\n]|\\\\.|\\[(?:[^[\\]\\\\\r\n]|\\\\.)*\\])*\\])*\\]|\\\\.|[^/\\\\\\[\r\n])+/[dgimyus]{0,7}v[dgimyus]{0,7})(?=(?:\\s|/\\*(?:[^*]|\\*(?!/))*\\*/)*(?:$|[\r\n,.;:})\\]]|//))"),
        lookbehind: !0,
        greedy: !0,
        inside: {
            "regex-source": {
                pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
                lookbehind: !0,
                alias: "language-regex",
                inside: Prism.languages.regex
            },
            "regex-delimiter": /^\/|\/$/,
            "regex-flags": /^[a-z]+$/
        }
    },
    "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
    },
    parameter: [ {
        pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
        lookbehind: !0,
        inside: Prism.languages.javascript
    }, {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
        lookbehind: !0,
        inside: Prism.languages.javascript
    }, {
        pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
        lookbehind: !0,
        inside: Prism.languages.javascript
    }, {
        pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
        lookbehind: !0,
        inside: Prism.languages.javascript
    } ],
    constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
}), Prism.languages.insertBefore("javascript", "string", {
    hashbang: {
        pattern: /^#!.*/,
        greedy: !0,
        alias: "comment"
    },
    "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: !0,
        inside: {
            "template-punctuation": {
                pattern: /^`|`$/,
                alias: "string"
            },
            interpolation: {
                pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
                lookbehind: !0,
                inside: {
                    "interpolation-punctuation": {
                        pattern: /^\$\{|\}$/,
                        alias: "punctuation"
                    },
                    rest: Prism.languages.javascript
                }
            },
            string: /[\s\S]+/
        }
    },
    "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: !0,
        greedy: !0,
        alias: "property"
    }
}), Prism.languages.insertBefore("javascript", "operator", {
    "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: !0,
        alias: "property"
    }
}), Prism.languages.markup && (Prism.languages.markup.tag.addInlined("script", "javascript"),
Prism.languages.markup.tag.addAttribute("on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)", "javascript")),
Prism.languages.js = Prism.languages.javascript;
Prism.languages.python = {
    comment: {
        pattern: /(^|[^\\])#.*/,
        lookbehind: !0,
        greedy: !0
    },
    "string-interpolation": {
        pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
        greedy: !0,
        inside: {
            interpolation: {
                pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
                lookbehind: !0,
                inside: {
                    "format-spec": {
                        pattern: /(:)[^:(){}]+(?=\}$)/,
                        lookbehind: !0
                    },
                    "conversion-option": {
                        pattern: /![sra](?=[:}]$)/,
                        alias: "punctuation"
                    },
                    rest: null
                }
            },
            string: /[\s\S]+/
        }
    },
    "triple-quoted-string": {
        pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
        greedy: !0,
        alias: "string"
    },
    string: {
        pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
        greedy: !0
    },
    function: {
        pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
        lookbehind: !0
    },
    "class-name": {
        pattern: /(\bclass\s+)\w+/i,
        lookbehind: !0
    },
    decorator: {
        pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
        lookbehind: !0,
        alias: [ "annotation", "punctuation" ],
        inside: {
            punctuation: /\./
        }
    },
    keyword: /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
    builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
    boolean: /\b(?:False|None|True)\b/,
    number: /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
    operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
    punctuation: /[{}[\];(),.:]/
}, Prism.languages.python["string-interpolation"].inside.interpolation.inside.rest = Prism.languages.python,
Prism.languages.py = Prism.languages.python;
Prism.languages.java = Prism.languages.extend("clike", {
    "class-name": [Prism.languages.clike["class-name"], {
        pattern: /(^|[^$\w.])(?!\s)[_$A-Z](?:(?!\s)[$\w])*(?=\s*\.\s*(?:[A-Z](?:[a-z]|\d)*(?:\.[A-Z](?:[a-z]|\d)*)*\.)*[A-Z](?:[a-z]|\d)*)/,
        lookbehind: !0,
        inside: {
            punctuation: /\./
        }
    }],
    keyword: /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?=\s*\()|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/,
    number: /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?[dfl]?/i,
    operator: {
        pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
        lookbehind: !0
    }
}), Prism.languages.insertBefore("java", "string", {
    "triple-quoted-string": {
        pattern: /"""[ \t]*[\r\n](?:.*[\r\n])*?[ \t]*"""/,
        greedy: !0,
        alias: "string"
    },
    "char": {
        pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
        greedy: !0
    }
}), Prism.languages.insertBefore("java", "class-name", {
    annotation: {
        pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
        lookbehind: !0,
        alias: "punctuation"
    },
    generics: {
        pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>/,
        inside: {
            "class-name": /\b[A-Z]\w*(?:\s*\.\s*[A-Z]\w*)*\b/,
            keyword: /\b(?:extends|super)\b/,
            punctuation: /[<>(),.:]/,
            operator: /[?&|]/
        }
    },
    import: [{
        pattern: /(\bimport\s+)static\s+[\w$.]+(?:\.[A-Z]\w*)?(?=\s*;)/,
        lookbehind: !0,
        alias: "static"
    }, {
        pattern: /(\bimport\s+)[\w$.]+(?:\.[A-Z]\w*)?(?=\s*;)/,
        lookbehind: !0,
        inside: {
            namespace: /\b\w+\.$/,
            punctuation: /\./
        }
    }],
    namespace: {
        pattern: /\b(?:module|open)\s+\w+\s*\.\s*[\w.]+/,
        inside: {
            punctuation: /\./
        }
    }
});
Prism.languages.c = Prism.languages.extend("clike", {
    comment: [{
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: !0,
        greedy: !0
    }, {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
    }],
    string: {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
    },
    "class-name": {
        pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
        lookbehind: !0
    },
    keyword: /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|catch|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
    function: /\b[a-z_]\w*(?=\s*\()/i,
    number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
    operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
}), Prism.languages.insertBefore("c", "string", {
    char: {
        pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
        greedy: !0
    }
}), Prism.languages.insertBefore("c", "string", {
    macro: {
        pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
        lookbehind: !0,
        greedy: !0,
        alias: "property",
        inside: {
            string: [{
                pattern: /^(#\s*include\s*)<[^>]+>/,
                lookbehind: !0
            }, Prism.languages.c.string],
            comment: Prism.languages.c.comment,
            "macro-name": [{
                pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
                lookbehind: !0
            }, {
                pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
                lookbehind: !0,
                alias: "function"
            }],
            directive: {
                pattern: /^(#\s*)[a-z]+/,
                lookbehind: !0,
                alias: "keyword"
            },
            "directive-hash": /^#/,
            punctuation: /##|\\(?=[\r\n])/,
            expression: {
                pattern: /\S[\s\S]*/,
                inside: Prism.languages.c
            }
        }
    },
    "constant": /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__VERSION__)\b/
});
delete Prism.languages.c["boolean"];
Prism.languages.typescript = Prism.languages.extend("javascript", {
    keyword: /\b(?:abstract|any|as|async|await|bigint|boolean|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|false|finally|for|from|function|get|globalThis|if|implements|import|in|infer|instanceof|interface|is|keyof|let|module|namespace|never|new|null|number|object|of|override|package|private|protected|public|readonly|require|return|set|static|string|super|switch|symbol|this|throw|true|try|type|typeof|undefined|unique|unknown|var|void|while|with|yield)\b/,
    builtin: /\b(?:Array|Boolean|console|Date|Error|Function|Intl|JSON|Math|Number|Object|Promise|RegExp|String|Symbol)\b/
}), Prism.languages.ts = Prism.languages.typescript;
Prism.languages.cpp = Prism.languages.extend('c', {
    'class-name': {
        pattern: /(\b(?:class|enum|struct)\s+)\w+/,
        lookbehind: true
    },
    'keyword': /\b(?:alignas|alignof|and|and_eq|asm|auto|bitand|bitor|bool|break|case|catch|char|char16_t|char32_t|class|compl|const|const_cast|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|false|float|for|friend|goto|if|inline|int|long|mutable|namespace|new|noexcept|nullptr|operator|or|or_eq|private|protected|public|register|reinterpret_cast|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|true|try|typedef|typeid|typename|union|unsigned|using|virtual|void|volatile|wchar_t|while|xor|xor_eq)\b/,
    'number': {
        pattern: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
        lookbehind: true
    },
    'operator': />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/
});
Prism.languages.insertBefore('cpp', 'string', {
    'raw-string': {
        pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
        alias: 'string',
        greedy: true
    }
});
Prism.languages.rust = {
    comment: [{
        pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
        lookbehind: !0,
        greedy: !0
    }, {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
    }],
    string: {
        pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
        greedy: !0
    },
    char: {
        pattern: /b?'(?:\\(?:x[0-7][0-7]|u\{(?:[0-9a-fA-F]{1,6}_?)*\}|.)|[^\\\r\n\t'])'/,
        greedy: !0
    },
    "lifetime-annotation": {
        pattern: /'[^\s>']+/,
        alias: "symbol"
    },
    keyword: /\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|false|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|true|try|type|typeof|unsafe|unsized|use|virtual|where|while|yield)\b/,
    "function-definition": {
        pattern: /(\bfn\s+)\w+/,
        lookbehind: !0,
        alias: "function"
    },
    "type-definition": {
        pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
        lookbehind: !0,
        alias: "class-name"
    },
    "module-declaration": [ {
        pattern: /(\b(?:crate|mod)\s+)[a-z][a-zA-Z0-9_]*/,
        lookbehind: !0,
        alias: "namespace"
    }, {
        pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-zA-Z0-9_]*/,
        lookbehind: !0,
        alias: "namespace",
        inside: {
            punctuation: /::/
        }
    } ],
    "function-call": {
        pattern: /\b[a-z_]\w*(?=\s*(?:::\s*<\s*\w+\s*>)?\s*\()/i,
        alias: "function"
    },
    "macro-call": {
        pattern: /\b\w+!/,
        alias: "constant"
    },
    "type-parameter": {
        pattern: /<\s*\w+\s*>/,
        inside: {
            punctuation: /[<>]/
        }
    },
    "boolean": /\b(?:false|true)\b/,
    "number": /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|128|size)))?\b/,
    "function": /\b[a-z_]\w*(?=\s*(?:::\s*\w+\s*)?::\s*\w+\s*\()/i,
    "macro": {
        pattern: /\b\w+!/,
        alias: "property"
    },
    "constant": /\b[A-Z_][A-Z_\d]+\b/,
    "class-name": /\b[A-Z]\w*\b/,
    "namespace": {
        pattern: /\b(?:[a-z_]\w*::)+/,
        inside: {
            punctuation: /::/
        }
    },
    punctuation: /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
    operator: /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/
};
Prism.languages.go = Prism.languages.extend("clike", {
    string: {
        pattern: /(["'`])(\\[\s\S]|(?!\1)[^\\])*\1/,
        greedy: !0
    },
    keyword: /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
    boolean: /\b(?:_|false|iota|nil|true)\b/,
    number: /(?:\b0x[a-f\d]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[-+]?\d+)?)i?/i,
    operator: /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
    builtin: /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|fmt|imag|index|int|int8|int16|int32|int64|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uint|uint8|uint16|uint32|uint64|uintptr)\b/
}), Prism.languages.insertBefore("go", "string", {
    char: {
        pattern: /'(?:\\(?:[abfnrtv\\']|x[0-7][0-7]|u[0-9a-fA-F]{4}|U[0-9a-fA-F]{8})|[^\\'\r\n])'/,
        greedy: !0
    }
});
Prism.languages.ruby = Prism.languages.extend("clike", {
    comment: [/#.*/, {
        pattern: /^=begin\s[\s\S]*?^=end/m,
        greedy: !0
    }],
    "class-name": {
        pattern: /(\b(?:class)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: !0,
        inside: {
            punctuation: /[.\\]/
        }
    },
    keyword: /\b(?:alias|and|BEGIN|begin|break|case|class|def|defined|do|else|elsif|END|end|ensure|false|for|if|in|module|new|next|nil|not|or|private|protected|public|raise|redo|require|rescue|retry|return|self|super|then|throw|true|undef|unless|until|when|while|yield)\b/
}), Prism.languages.insertBefore("ruby", "operator", {
    "double-colon": {
        pattern: /::/,
        alias: "punctuation"
    }
}), Prism.languages.insertBefore("ruby", "string", {
    "string": [ {
        pattern: /("|')(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|(?!\1)[^\\#\r\n])*\1/,
        greedy: !0,
        inside: {
            interpolation: {
                pattern: /#\{[^}]+\}/,
                inside: {
                    delimiter: {
                        pattern: /^#\{|\}$/,
                        alias: "variable"
                    },
                    rest: Prism.languages.ruby
                }
            },
            string: /[\s\S]+/
        }
    }, {
        pattern: /\b\w+\s*\/(?:[^\/\r\n\\]|\\.)+\//,
        greedy: !0,
        inside: {
            regex: {
                pattern: /^\/|\/[gim]*$/,
                alias: "operator"
            },
            string: /[\s\S]+/
        }
    } ]
}), Prism.languages.insertBefore("ruby", "comment", {
    "regex": [ {
        pattern: /%r([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1[gim]*/,
        greedy: !0,
        inside: {
            interpolation: {
                pattern: /#\{[^}]+\}/,
                inside: {
                    delimiter: {
                        pattern: /^#\{|\}$/,
                        alias: "variable"
                    },
                    rest: Prism.languages.ruby
                }
            },
            regex: {
                pattern: /(^%r.|.)[gim]*$/,
                lookbehind: !0,
                alias: "operator"
            },
            string: /[\s\S]+/
        }
    }, {
        pattern: /%r\((?:[^()\\]|\\[\s\S])*\)[gim]*/,
        greedy: !0,
        inside: {
            interpolation: {
                pattern: /#\{[^}]+\}/,
                inside: {
                    delimiter: {
                        pattern: /^#\{|\}$/,
                        alias: "variable"
                    },
                    rest: Prism.languages.ruby
                }
            },
            regex: {
                pattern: /(^%r.|.)[gim]*$/,
                lookbehind: !0,
                alias: "operator"
            },
            string: /[\s\S]+/
        }
    }, {
        pattern: /%r\{(?:[^{}\\]|\\[\s\S])*\}[gim]*/,
        greedy: !0,
        inside: {
            interpolation: {
                pattern: /#\{[^}]+\}/,
                inside: {
                    delimiter: {
                        pattern: /^#\{|\}$/,
                        alias: "variable"
                    },
                    rest: Prism.languages.ruby
                }
            },
            regex: {
                pattern: /(^%r.|.)[gim]*$/,
                lookbehind: !0,
                alias: "operator"
            },
            string: /[\s\S]+/
        }
    }, {
        pattern: /%r\[(?:[^\[\]\\]|\\[\s\S])*\][gim]*/,
        greedy: !0,
        inside: {
            interpolation: {
                pattern: /#\{[^}]+\}/,
                inside: {
                    delimiter: {
                        pattern: /^#\{|\}$/,
                        alias: "variable"
                    },
                    rest: Prism.languages.ruby
                }
            },
            regex: {
                pattern: /(^%r.|.)[gim]*$/,
                lookbehind: !0,
                alias: "operator"
            },
            string: /[\s\S]+/
        }
    }, {
        pattern: /%r<(?:[^<>\\]|\\[\s\S])*>[gim]*/,
        greedy: !0,
        inside: {
            interpolation: {
                pattern: /#\{[^}]+\}/,
                inside: {
                    delimiter: {
                        pattern: /^#\{|\}$/,
                        alias: "variable"
                    },
                    rest: Prism.languages.ruby
                }
            },
            regex: {
                pattern: /(^%r.|.)[gim]*$/,
                lookbehind: !0,
                alias: "operator"
            },
            string: /[\s\S]+/
        }
    } ]
}), Prism.languages.insertBefore("ruby", "string", {
    "symbol": {
        pattern: /:[a-zA-Z_]\w*(?:[?!](?![a-zA-Z_]\w*)?)?/,
        alias: "variable"
    }
});
Prism.languages.php = Prism.languages.extend("clike", {
    keyword: /\b(?:__halt_compiler|abstract|and|array|as|break|callable|case|catch|class|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|eval|exit|extends|final|finally|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|namespace|new|or|parent|print|private|protected|public|require|require_once|return|static|switch|throw|trait|try|unset|use|var|while|xor|yield)\b/i,
    "boolean": /\b(?:false|null|true)\b/i,
    "function": /\b\w+(?=\s*\()/,
    "number": /\b(?:0x[a-f\d]+|\d+\.?\d*(?:e[+-]?\d+)?)/i,
    "operator": {
        pattern: /(^|[^"\.])(?:\+[+=]?|-[-=>]?|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[!=]=?=?|[&|^]=?|~|\b(?:and|or|xor)\b)/,
        lookbehind: !0
    }
}), Prism.languages.insertBefore("php", "keyword", {
    delimiter: {
        pattern: /\?>|<\?(?:php|=)?/i,
        alias: "important"
    }
}), Prism.languages.insertBefore("php", "comment", {
    "comment": [{
        pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
        lookbehind: !0,
        greedy: !0
    }, {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
    }],
    "variable": /\$+(?:\w+\b|(?=\{))/
}), Prism.languages.insertBefore("php", "string", {
    "shell-comment": {
        pattern: /(^|[^\\])#.*/,
        lookbehind: !0,
        greedy: !0,
        alias: "comment"
    }
}), Prism.languages.insertBefore("php", "comment", {
    "delimiter": {
        pattern: /(^|[^\\])<<<'([^']+)'[\r\n](?:.*[\r\n])*?\2;/,
        lookbehind: !0,
        greedy: !0,
        alias: "comment",
        inside: {
            punctuation: /^<<<'[^']+'|[a-z_]\w*;$/i
        }
    }
}), Prism.languages.insertBefore("php", "string", {
    "shell-string": {
        pattern: /\$`(?:\\[\s\S]|[^\\`])*`/,
        greedy: !0,
        inside: {
            interpolation: {
                pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
                lookbehind: !0,
                inside: {
                    "interpolation-punctuation": {
                        pattern: /^\$\{|\}$/,
                        alias: "punctuation"
                    },
                    rest: Prism.languages.php
                }
            },
            variable: /\$+(?:\w+\b|(?=\{))/
        }
    }
}), Prism.languages.insertBefore("php", "string", {
    "nowdoc-string": {
        pattern: /<<<'([^']+)'[\r\n](?:.*[\r\n])*?\1;/,
        greedy: !0,
        alias: "string",
        inside: {
            punctuation: /^<<<'[^']+'|[a-z_]\w*;$/i
        }
    }
}), Prism.languages.insertBefore("php", "string", {
    "heredoc-string": {
        pattern: /<<<(?:"([^"]+)"[\r\n](?:.*[\r\n])*?\1;|([a-z_]\w*)[\r\n](?:.*[\r\n])*?\2;)/i,
        greedy: !0,
        alias: "string",
        inside: {
            interpolation: {
                pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
                lookbehind: !0,
                inside: {
                    "interpolation-punctuation": {
                        pattern: /^\$\{|\}$/,
                        alias: "punctuation"
                    },
                    rest: Prism.languages.php
                }
            },
            variable: /\$+(?:\w+\b|(?=\{))/,
            punctuation: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i
        }
    }
}), Prism.languages.insertBefore("php", "comment", {
    "delimiter": {
        pattern: /\?>|<\?(?:php|=)?/i,
        alias: "important"
    }
}), Prism.languages.insertBefore("php", "keyword", {
    "delimiter": {
        pattern: /(^|[^\\])<<<'([^']+)'[\r\n](?:.*[\r\n])*?\2;/,
        lookbehind: !0,
        greedy: !0,
        alias: "comment",
        inside: {
            punctuation: /^<<<'[^']+'|[a-z_]\w*;$/i
        }
    }
}), Prism.languages.insertBefore("php", "string", {
    "shell-comment": {
        pattern: /(^|[^\\])#.*/,
        lookbehind: !0,
        greedy: !0,
        alias: "comment"
    }
}), Prism.languages.insertBefore("php", "keyword", {
    "delimiter": {
        pattern: /\?>|<\?(?:php|=)?/i,
        alias: "important"
    }
});
Prism.languages.swift = Prism.languages.extend("clike", {
    string: {
        pattern: /("|')(?:\\(?:\((?:[^()]|\([^)]+\))+\)|\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: !0,
        inside: {
            interpolation: {
                pattern: /\\\((?:[^()]|\([^)]+\))+\)/,
                inside: {
                    delimiter: {
                        pattern: /^\\\(|\)$/,
                        alias: "variable"
                    }
                }
            }
        }
    },
    keyword: /\b(?:as|associativity|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|dynamicType|else|enum|extension|fallthrough|final|for|func|get|guard|if|import|in|infix|init|inout|internal|is|lazy|left|let|mutating|new|none|nonmutating|operator|optional|override|postfix|precedence|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|Self|set|static|struct|subscript|super|switch|throw|throws|try|Type|typealias|unowned|unsafe|var|weak|where|while|willSet|__(?:COLUMN__|FILE__|FUNCTION__|LINE__))\b/,
    number: /\b(?:[\d_]+(?:\.[\d_]+)?(?:e[-+]?[\d_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?(?:p[-+]?[\d_]+)?|0o[0-7_]+|0b[01_]+)\b/i,
    constant: /\b(?:nil|true|false|__COLUMN__|__FILE__|__FUNCTION__|__LINE__)\b/,
    "atrule": /@\b(?:availability|autoclosure|noreturn|NSApplicationMain|NSCopying|NSManaged|objc|UIApplicationMain|IBAction|IBDesignable|IBInspectable|IBOutlet)\b/,
    "builtin": /\b(?:[A-Z]\w*)\b/,
    "class-name": /\b[A-Z]\w*\b/,
    "function": /[a-z_]\w*(?=\s*\()/i
}), Prism.languages.insertBefore("swift", "operator", {
    "attribute": {
        pattern: /@\w+/,
        alias: "atrule"
    }
}), Prism.languages.insertBefore("swift", "string", {
    "literal": {
        pattern: /#"([^"]|"(?!"#))*"#/,
        greedy: !0
    }
});
    </script>

    <script>
        // --- Global State ---
        const state = {
            currentTool: 'select',
            currentProject: null,
            projects: JSON.parse(localStorage.getItem('codecanvas_projects')) || {},
            canvas: {
                zoom: 1,
                panX: 0,
                panY: 0,
                elements: [],
                selectedElements: [], // Support for multi-select
                isPanning: false,
                isSpacePanning: false,
                startPoint: null,
                currentPath: null,
                isDrawing: false,
                isCreatingConnector: false,
                connectorStartPoint: null,
                tempConnector: null,
                gridSize: 20, // Default grid size
                snapToGrid: true
            },
            history: {
                undoStack: [],
                redoStack: [],
                _saveTimeout: null
            },
            settings: {
                theme: localStorage.getItem('codecanvas_theme') || 'dark',
                autosaveInterval: parseInt(localStorage.getItem('codecanvas_autosave_interval')) || 30,
                gridSpacing: parseInt(localStorage.getItem('codecanvas_grid_spacing')) || 20,
                snapToGrid: localStorage.getItem('codecanvas_snap_to_grid') === 'true'
            },
            brushSettings: {
                color: '#ffffff',
                size: 3,
                opacity: 1
            },
            textSettings: {
                fontFamily: 'Inter, Segoe UI, Roboto, Helvetica, Arial, sans-serif',
                fontSize: 16,
                color: '#cccccc',
                bold: false,
                italic: false,
                underline: false,
                align: 'left' // left, center, right
            },
            shapeSettings: {
                type: 'rectangle',
                fillColor: '#4ec9b0',
                strokeColor: '#ffffff',
                strokeWidth: 2,
                width: 100,
                height: 60
            },
            connectorSettings: {
                strokeColor: '#cccccc',
                strokeWidth: 2,
                arrowheads: 'end' // 'start', 'end', 'both', 'none'
            },
            codeSettings: {
                language: 'javascript'
            }
        };

        // --- Utility Functions ---
        function generateId() {
            return 'el_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        function showNotification(message, isError = false) {
            const notification = document.createElement('div');
            notification.className = 'notification';
            if (isError) {
                notification.style.borderColor = 'var(--accent-danger)';
                notification.style.color = 'var(--accent-danger)';
            }
            notification.textContent = message;
            document.body.appendChild(notification);
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 3000);
        }

        function snapToGrid(value, gridSize = state.canvas.gridSize) {
            if (!state.settings.snapToGrid) return value;
            return Math.round(value / gridSize) * gridSize;
        }

        function getViewportCenter() {
             const container = document.getElementById('canvasContainer');
             const rect = container.getBoundingClientRect();
             return {
                 x: (rect.width / 2 - state.canvas.panX) / state.canvas.zoom,
                 y: (rect.height / 2 - state.canvas.panY) / state.canvas.zoom
             };
        }

        // --- Theme Management ---
        function applyTheme(themeName) {
            document.documentElement.setAttribute('data-theme', themeName);
            state.settings.theme = themeName;
            localStorage.setItem('codecanvas_theme', themeName);

            // Update connector marker color to match theme
            const marker = document.querySelector('#arrowhead polygon');
            if (marker) {
                marker.setAttribute('fill', getComputedStyle(document.documentElement).getPropertyValue('--text-primary').trim());
            }

            // Re-highlight all code blocks
            document.querySelectorAll('pre.code-element').forEach(pre => {
                const code = pre.querySelector('code');
                if (code && code.className) {
                    Prism.highlightElement(code);
                }
            });
        }

        // --- Canvas Transformations ---
        function updateCanvasTransform() {
            const canvas = document.getElementById('canvas');
            canvas.style.transform = `translate(${state.canvas.panX}px, ${state.canvas.panY}px) scale(${state.canvas.zoom})`;
        }

        function updateZoomDisplay() {
            const zoomPercent = Math.round(state.canvas.zoom * 100);
            document.getElementById('zoomLevelInput').value = `${zoomPercent}%`;
        }

        function zoom(factor, clientX, clientY) {
            const oldZoom = state.canvas.zoom;
            const containerRect = document.getElementById('canvasContainer').getBoundingClientRect();

            // Calculate mouse position relative to canvas before zoom
            const mouseX = (clientX - containerRect.left - state.canvas.panX) / oldZoom;
            const mouseY = (clientY - containerRect.top - state.canvas.panY) / oldZoom;

            state.canvas.zoom *= factor;
            state.canvas.zoom = Math.max(0.1, Math.min(5, state.canvas.zoom));

            // Adjust pan to keep mouse position fixed
            state.canvas.panX = clientX - containerRect.left - mouseX * state.canvas.zoom;
            state.canvas.panY = clientY - containerRect.top - mouseY * state.canvas.zoom;

            updateCanvasTransform();
            updateZoomDisplay();
            saveToHistory(); // Save zoom state
        }

        function resetZoom() {
            state.canvas.zoom = 1;
            const container = document.getElementById('canvasContainer');
            const contentBounds = getCanvasContentBounds();
            const centerX = (contentBounds.minX + contentBounds.maxX) / 2;
            const centerY = (contentBounds.minY + contentBounds.maxY) / 2;

            state.canvas.panX = container.clientWidth / 2 - centerX * state.canvas.zoom;
            state.canvas.panY = container.clientHeight / 2 - centerY * state.canvas.zoom;
            updateCanvasTransform();
            updateZoomDisplay();
            saveToHistory();
        }

        function fitToScreen() {
            const container = document.getElementById('canvasContainer');
            const contentBounds = getCanvasContentBounds();

            if (contentBounds.minX === Infinity) {
                // No content, reset to default view
                resetZoom();
                return;
            }

            const contentWidth = contentBounds.maxX - contentBounds.minX;
            const contentHeight = contentBounds.maxY - contentBounds.minY;

            const scaleX = (container.clientWidth * 0.9) / contentWidth;
            const scaleY = (container.clientHeight * 0.9) / contentHeight;
            const newZoom = Math.min(scaleX, scaleY, 1); // Don't zoom in more than 100%

            state.canvas.zoom = newZoom;
            state.canvas.panX = container.clientWidth / 2 - ((contentBounds.minX + contentBounds.maxX) / 2) * newZoom;
            state.canvas.panY = container.clientHeight / 2 - ((contentBounds.minY + contentBounds.maxY) / 2) * newZoom;

            updateCanvasTransform();
            updateZoomDisplay();
            saveToHistory();
        }

        function getCanvasContentBounds() {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            state.canvas.elements.forEach(el => {
                const rect = el.element.getBoundingClientRect();
                const canvasRect = document.getElementById('canvas').getBoundingClientRect();
                const x1 = (rect.left - canvasRect.left - state.canvas.panX) / state.canvas.zoom;
                const y1 = (rect.top - canvasRect.top - state.canvas.panY) / state.canvas.zoom;
                const x2 = x1 + rect.width / state.canvas.zoom;
                const y2 = y1 + rect.height / state.canvas.zoom;

                minX = Math.min(minX, x1);
                minY = Math.min(minY, y1);
                maxX = Math.max(maxX, x2);
                maxY = Math.max(maxY, y2);
            });

            // If no elements, return a default view
            if (minX === Infinity) {
                minX = -1000;
                minY = -1000;
                maxX = 1000;
                maxY = 1000;
            }

            return { minX, minY, maxX, maxY };
        }

        function toggleGrid() {
            const canvas = document.getElementById('canvas');
            canvas.classList.toggle('no-grid');
        }

        // --- History Management ---
        function saveToHistory(action = "Action") {
            // Debounce saving to prevent excessive snapshots
            if (state.history._saveTimeout) {
                clearTimeout(state.history._saveTimeout);
            }
            state.history._saveTimeout = setTimeout(() => {
                const snapshot = {
                    action: action,
                    canvas: {
                        zoom: state.canvas.zoom,
                        panX: state.canvas.panX,
                        panY: state.canvas.panY,
                        elements: state.canvas.elements.map(el => serializeElement(el))
                    }
                };
                state.history.undoStack.push(JSON.stringify(snapshot));
                state.history.redoStack = [];
                if (state.history.undoStack.length > 100) { // Cap history
                    state.history.undoStack.shift();
                }
                delete state.history._saveTimeout;
            }, 100); // 100ms debounce
        }

        function serializeElement(element) {
             let content = '';
            if (element.type === 'text') {
                content = element.element.value;
            } else if (element.type === 'code') {
                content = element.element.querySelector('code').textContent;
            } else {
                content = element.element.innerHTML;
            }
            return {
                type: element.type,
                id: element.id,
                x: element.x,
                y: element.y,
                width: element.width,
                height: element.height,
                content: content,
                style: element.element.getAttribute('style'),
                attributes: getElementAttributes(element),
                isLocked: element.isLocked || false
            };
        }

        function getElementAttributes(element) {
            const attrs = {};
            if (element.type === 'shape') {
                attrs.shapeType = element.shapeType;
                attrs.fillColor = element.fillColor;
                attrs.strokeColor = element.strokeColor;
                attrs.strokeWidth = element.strokeWidth;
            } else if (element.type === 'code') {
                attrs.language = element.language;
            } else if (element.type === 'connector') {
                 attrs.startElementId = element.startElementId;
                 attrs.endElementId = element.endElementId;
                 attrs.startPoint = element.startPoint;
                 attrs.endPoint = element.endPoint;
                 attrs.label = element.label;
                 attrs.pathData = element.pathData;
                 attrs.strokeColor = element.strokeColor;
                 attrs.strokeWidth = element.strokeWidth;
                 attrs.arrowheads = element.arrowheads;
            }
            return attrs;
        }

        function undo() {
            if (state.history.undoStack.length === 0) return;
            const currentSnapshot = {
                action: "Undo Snapshot",
                canvas: {
                    zoom: state.canvas.zoom,
                    panX: state.canvas.panX,
                    panY: state.canvas.panY,
                    elements: state.canvas.elements.map(el => serializeElement(el))
                }
            };
            state.history.redoStack.push(JSON.stringify(currentSnapshot));

            const snapshotStr = state.history.undoStack.pop();
            const snapshot = JSON.parse(snapshotStr);
            restoreSnapshot(snapshot);
            showNotification(`Undo: ${snapshot.action}`);
        }

        function redo() {
            if (state.history.redoStack.length === 0) return;
            const currentSnapshot = {
                action: "Redo Snapshot",
                canvas: {
                    zoom: state.canvas.zoom,
                    panX: state.canvas.panX,
                    panY: state.canvas.panY,
                    elements: state.canvas.elements.map(el => serializeElement(el))
                }
            };
            state.history.undoStack.push(JSON.stringify(currentSnapshot));

            const snapshotStr = state.history.redoStack.pop();
            const snapshot = JSON.parse(snapshotStr);
            restoreSnapshot(snapshot);
            showNotification(`Redo: ${snapshot.action}`);
            saveToHistory(); // Save the redo action
        }

        function restoreSnapshot(snapshot) {
            // Clear canvas
            state.canvas.elements.forEach(el => {
                if (el.element && el.element.parentNode) {
                    el.element.parentNode.removeChild(el.element);
                }
            });
            state.canvas.elements = [];
            state.canvas.selectedElements = [];
            updatePropertiesPanel();

            // Restore canvas state
            state.canvas.zoom = snapshot.canvas.zoom;
            state.canvas.panX = snapshot.canvas.panX;
            state.canvas.panY = snapshot.canvas.panY;
            updateCanvasTransform();
            updateZoomDisplay();

            // Restore elements
            snapshot.canvas.elements.forEach(data => {
                createElementFromData(data);
            });
        }


        // --- Element Creation and Manipulation ---
        function selectTool(tool) {
            state.currentTool = tool;
            document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[data-tool="${tool}"]`).classList.add('active');
            updatePropertiesPanel();
            const canvasContainer = document.getElementById('canvasContainer');
            canvasContainer.style.cursor = getCursorForTool(tool);

            // Reset connector creation state if switching tools
            if (tool !== 'connector') {
                state.canvas.isCreatingConnector = false;
                state.canvas.connectorStartPoint = null;
                if (state.canvas.tempConnector) {
                    state.canvas.tempConnector.remove();
                    state.canvas.tempConnector = null;
                }
            }
        }

        function getCursorForTool(tool) {
            switch(tool) {
                case 'select': return 'default';
                case 'brush':
                case 'eraser':
                case 'shape':
                case 'connector':
                case 'code': return 'crosshair';
                case 'text': return 'text';
                default: return 'default';
            }
        }

        function updatePropertiesPanel() {
            // Hide all panels first
            document.getElementById('brushProperties').style.display = 'none';
            document.getElementById('textProperties').style.display = 'none';
            document.getElementById('shapeProperties').style.display = 'none';
            document.getElementById('connectorProperties').style.display = 'none';
            document.getElementById('codeProperties').style.display = 'none';
            document.getElementById('elementProperties').style.display = 'none';

            // Show tool-specific panel
            switch(state.currentTool) {
                case 'brush':
                case 'eraser':
                    document.getElementById('brushProperties').style.display = 'block';
                    break;
                case 'text':
                    document.getElementById('textProperties').style.display = 'block';
                    break;
                case 'shape':
                    document.getElementById('shapeProperties').style.display = 'block';
                    break;
                case 'connector':
                    document.getElementById('connectorProperties').style.display = 'block';
                    break;
                case 'code':
                    document.getElementById('codeProperties').style.display = 'block';
                    break;
            }

            // Show element properties if elements are selected
            if (state.canvas.selectedElements.length > 0) {
                document.getElementById('elementProperties').style.display = 'block';
                // Update position/size inputs
                if (state.canvas.selectedElements.length === 1) {
                    const el = state.canvas.selectedElements[0];
                    document.getElementById('elementX').value = Math.round(el.x);
                    document.getElementById('elementY').value = Math.round(el.y);
                    if (el.width !== undefined) document.getElementById('elementWidth').value = Math.round(el.width);
                    if (el.height !== undefined) document.getElementById('elementHeight').value = Math.round(el.height);
                } else {
                    document.getElementById('elementX').value = '';
                    document.getElementById('elementY').value = '';
                    document.getElementById('elementWidth').value = '';
                    document.getElementById('elementHeight').value = '';
                }
            }
        }

        function clearSelection() {
            state.canvas.selectedElements.forEach(el => {
                if (el.element) el.element.classList.remove('selected');
            });
            state.canvas.selectedElements = [];
            updatePropertiesPanel();
        }

        function selectElement(element, isMultiSelect = false) {
            if (!isMultiSelect) {
                clearSelection();
            }

            // Toggle selection for multi-select
            if (isMultiSelect && state.canvas.selectedElements.includes(element)) {
                element.element.classList.remove('selected');
                const index = state.canvas.selectedElements.indexOf(element);
                state.canvas.selectedElements.splice(index, 1);
            } else {
                element.element.classList.add('selected');
                state.canvas.selectedElements.push(element);
            }
            updatePropertiesPanel();
        }

        function deleteSelectedElements() {
            if (state.canvas.selectedElements.length === 0) return;

            const elementsToDelete = [...state.canvas.selectedElements]; // Copy array as it will be modified
            elementsToDelete.forEach(element => {
                const index = state.canvas.elements.indexOf(element);
                if (index > -1) {
                    // If deleting a shape, also delete connectors attached to it
                    if (element.type === 'shape') {
                         state.canvas.elements = state.canvas.elements.filter(el => {
                            if (el.type === 'connector' && (el.startElementId === element.id || el.endElementId === element.id)) {
                                if (el.element && el.element.parentNode) {
                                    el.element.parentNode.removeChild(el.element);
                                }
                                return false; // Remove connector
                            }
                            return true; // Keep other elements
                        });
                    }
                    // Remove the element itself
                    if (element.element && element.element.parentNode) {
                        element.element.parentNode.removeChild(element.element);
                    }
                    state.canvas.elements.splice(index, 1);
                }
            });

            clearSelection();
            saveToHistory("Delete Elements");
        }

        function lockSelectedElements() {
             state.canvas.selectedElements.forEach(el => {
                el.isLocked = !el.isLocked;
                if (el.isLocked) {
                    el.element.style.opacity = '0.7';
                    el.element.style.pointerEvents = 'none';
                     showNotification(`Locked ${state.canvas.selectedElements.length} element(s)`);
                } else {
                    el.element.style.opacity = '1';
                    el.element.style.pointerEvents = 'all';
                     showNotification(`Unlocked ${state.canvas.selectedElements.length} element(s)`);
                }
            });
            saveToHistory("Lock/Unlock Elements");
        }

        function duplicateSelectedElements() {
            if (state.canvas.selectedElements.length === 0) return;
            clearSelection(); // Deselect originals

            const newElements = [];
            state.canvas.selectedElements.forEach(originalEl => {
                const data = serializeElement(originalEl);
                data.x += 20; // Offset
                data.y += 20;
                data.id = generateId(); // New ID
                const newEl = createElementFromData(data);
                if (newEl) {
                    newElements.push(newEl);
                }
            });

            // Select the new elements
            newElements.forEach(el => selectElement(el, true));

            saveToHistory("Duplicate Elements");
            showNotification(`Duplicated ${newElements.length} element(s)`);
        }

        function groupSelectedElements() {
             if (state.canvas.selectedElements.length < 2) {
                showNotification("Select at least 2 elements to group.", true);
                return;
            }
            // Grouping logic would involve creating a new 'group' element type
            // and moving selected elements inside it.
            // This is a placeholder for the concept.
            showNotification("Grouping is a planned feature.");
        }

        function changeElementOrder(direction) {
            if (state.canvas.selectedElements.length === 0) return;
            let changed = false;
            state.canvas.selectedElements.forEach(element => {
                const currentZ = parseInt(window.getComputedStyle(element.element).zIndex) || 0;
                let newZ;
                if (direction === 'front') {
                    newZ = Math.max(10, ...state.canvas.elements.map(e => parseInt(window.getComputedStyle(e.element).zIndex) || 0)) + 1;
                } else { // back
                    newZ = Math.min(-10, ...state.canvas.elements.map(e => parseInt(window.getComputedStyle(e.element).zIndex) || 0)) - 1;
                }
                if (currentZ !== newZ) {
                    element.element.style.zIndex = newZ;
                    changed = true;
                }
            });
            if (changed) {
                saveToHistory(direction === 'front' ? "Bring to Front" : "Send to Back");
            }
        }

        function startDragging(e, element) {
            if (element.isLocked) return;
            e.preventDefault();
            const startX = e.clientX;
            const startY = e.clientY;
            const startLeft = parseFloat(element.element.style.left) || 0;
            const startTop = parseFloat(element.element.style.top) || 0;

            function handleDrag(e) {
                const dx = (e.clientX - startX) / state.canvas.zoom;
                const dy = (e.clientY - startY) / state.canvas.zoom;
                const newX = snapToGrid(startLeft + dx);
                const newY = snapToGrid(startTop + dy);
                element.element.style.left = newX + 'px';
                element.element.style.top = newY + 'px';
                element.x = newX;
                element.y = newY;

                // If it's a shape, update any connectors attached to it
                if (element.type === 'shape') {
                    updateConnectedConnectors(element);
                }
            }

            function stopDrag() {
                document.removeEventListener('mousemove', handleDrag);
                document.removeEventListener('mouseup', stopDrag);
                if (startLeft !== element.x || startTop !== element.y) {
                    saveToHistory("Move Element");
                }
            }

            document.addEventListener('mousemove', handleDrag);
            document.addEventListener('mouseup', stopDrag);
        }

        function startResizing(e, element, handle) {
            if (element.isLocked) return;
            e.preventDefault();
            e.stopPropagation(); // Prevent dragging from starting
            const startX = e.clientX;
            const startY = e.clientY;
            const startWidth = element.width || element.element.offsetWidth;
            const startHeight = element.height || element.element.offsetHeight;
            const startLeft = parseFloat(element.element.style.left) || 0;
            const startTop = parseFloat(element.element.style.top) || 0;

            function handleResize(e) {
                const dx = (e.clientX - startX) / state.canvas.zoom;
                const dy = (e.clientY - startY) / state.canvas.zoom;

                let newWidth = startWidth;
                let newHeight = startHeight;
                let newLeft = startLeft;
                let newTop = startTop;

                if (handle.includes('right')) {
                    newWidth = Math.max(20, snapToGrid(startWidth + dx));
                }
                if (handle.includes('bottom')) {
                    newHeight = Math.max(20, snapToGrid(startHeight + dy));
                }
                if (handle.includes('left')) {
                    const diff = snapToGrid(dx);
                    newWidth = Math.max(20, startWidth - diff);
                    newLeft = startLeft + (startWidth - newWidth);
                }
                if (handle.includes('top')) {
                    const diff = snapToGrid(dy);
                    newHeight = Math.max(20, startHeight - diff);
                    newTop = startTop + (startHeight - newHeight);
                }

                element.element.style.width = newWidth + 'px';
                element.element.style.height = newHeight + 'px';
                element.element.style.left = newLeft + 'px';
                element.element.style.top = newTop + 'px';
                element.x = newLeft;
                element.y = newTop;
                element.width = newWidth;
                element.height = newHeight;

                // If it's a shape, update its internal SVG
                if (element.type === 'shape') {
                    updateShapeSVG(element);
                }
                // If it's a code block, it will resize naturally
                // If it's a connector, resizing a shape will trigger connector updates
            }

            function stopResize() {
                document.removeEventListener('mousemove', handleResize);
                document.removeEventListener('mouseup', stopResize);
                saveToHistory("Resize Element");
            }

            document.addEventListener('mousemove', handleResize);
            document.addEventListener('mouseup', stopResize);
        }

        // --- Drawing Tools ---
        function startDrawing(x, y) {
            state.canvas.isDrawing = true;
            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, 'svg');
            svg.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;';
            svg.setAttribute('class', 'canvas-element');
            svg.setAttribute('id', generateId());

            state.canvas.currentPath = svg;
            state.canvas.elements.push({
                type: 'drawing',
                element: svg,
                id: svg.id,
                x: 0, // Drawings are relative to canvas
                y: 0
            });
            document.getElementById('canvas').appendChild(svg);
        }

        function drawLine(x1, y1, x2, y2) {
            if (!state.canvas.currentPath) return;
            const svgNS = "http://www.w3.org/2000/svg";
            const line = document.createElementNS(svgNS, 'line');
            line.setAttribute('x1', x1);
            line.setAttribute('y1', y1);
            line.setAttribute('x2', x2);
            line.setAttribute('y2', y2);
            line.setAttribute('stroke', state.brushSettings.color);
            line.setAttribute('stroke-width', state.brushSettings.size);
            line.setAttribute('stroke-opacity', state.brushSettings.opacity);
            line.setAttribute('stroke-linecap', 'round');
            state.canvas.currentPath.appendChild(line);
        }

        function startErasing(x, y) {
             // True erasing on SVG is complex. This is a simplified version that draws with background color.
             // A more robust solution would involve hit-testing and removing actual SVG elements.
             const originalColor = state.brushSettings.color;
             const originalOpacity = state.brushSettings.opacity;
             state.brushSettings.color = getComputedStyle(document.documentElement).getPropertyValue('--bg-canvas').trim();
             state.brushSettings.opacity = 1;
             startDrawing(x, y);
             state.brushSettings.color = originalColor;
             state.brushSettings.opacity = originalOpacity;
        }

        function eraseLine(x1, y1, x2, y2) {
             // Simplified eraser
             const originalColor = state.brushSettings.color;
             const originalOpacity = state.brushSettings.opacity;
             state.brushSettings.color = getComputedStyle(document.documentElement).getPropertyValue('--bg-canvas').trim();
             state.brushSettings.opacity = 1;
             drawLine(x1, y1, x2, y2);
             state.brushSettings.color = originalColor;
             state.brushSettings.opacity = originalOpacity;
        }


        // --- Text Tool ---
        function createTextElement(x, y) {
            const textarea = document.createElement('textarea');
            textarea.className = 'text-element canvas-element';
            textarea.style.left = snapToGrid(x) + 'px';
            textarea.style.top = snapToGrid(y) + 'px';
            textarea.style.fontFamily = state.textSettings.fontFamily;
            textarea.style.fontSize = state.textSettings.fontSize + 'px';
            textarea.style.color = state.textSettings.color;
            textarea.style.fontWeight = state.textSettings.bold ? 'bold' : 'normal';
            textarea.style.fontStyle = state.textSettings.italic ? 'italic' : 'normal';
            textarea.style.textDecoration = state.textSettings.underline ? 'underline' : 'none';
            textarea.style.textAlign = state.textSettings.align;
            textarea.placeholder = 'Type here...';

            const element = {
                type: 'text',
                element: textarea,
                id: generateId(),
                x: snapToGrid(x),
                y: snapToGrid(y),
                width: 150, // Initial width
                height: 60  // Initial height
            };
            element.element.style.width = element.width + 'px';
            element.element.style.height = element.height + 'px';

            state.canvas.elements.push(element);
            document.getElementById('canvas').appendChild(textarea);
            textarea.focus();

            textarea.addEventListener('mousedown', (e) => {
                if (state.currentTool === 'select') {
                    const isMulti = e.shiftKey;
                    selectElement(element, isMulti);
                    if (!isMulti && !element.isLocked) startDragging(e, element);
                    e.stopPropagation();
                }
            });
            textarea.addEventListener('input', () => {
                // Autosize textarea
                textarea.style.height = 'auto';
                textarea.style.height = textarea.scrollHeight + 'px';
                element.height = textarea.scrollHeight;
                saveToHistory("Edit Text");
            });
            textarea.addEventListener('blur', saveToHistory);

            selectElement(element);
            saveToHistory("Create Text");
        }

        // --- Shape Tool ---
        function createShapeElement(x, y) {
            const width = state.shapeSettings.width;
            const height = state.shapeSettings.height;
            let shapeSVG, shapePathData;

            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, 'svg');
            svg.style.cssText = `position: absolute; left: ${snapToGrid(x)}px; top: ${snapToGrid(y)}px; width: ${width}px; height: ${height}px;`;
            svg.setAttribute('class', 'canvas-element shape-element');
            svg.setAttribute('id', generateId());

            switch(state.shapeSettings.type) {
                case 'process': // Rectangle
                    shapeSVG = document.createElementNS(svgNS, 'rect');
                    shapeSVG.setAttribute('width', width);
                    shapeSVG.setAttribute('height', height);
                    shapeSVG.setAttribute('rx', '6');
                    shapePathData = `M0,0 L${width},0 L${width},${height} L0,${height} Z`;
                    break;
                case 'decision': // Diamond
                    shapeSVG = document.createElementNS(svgNS, 'polygon');
                    const points = `${width/2},0 ${width},${height/2} ${width/2},${height} 0,${height/2}`;
                    shapeSVG.setAttribute('points', points);
                    shapePathData = `M${width/2},0 L${width},${height/2} L${width/2},${height} L0,${height/2} Z`;
                    break;
                case 'terminator': // Rounded Rectangle (more rounded)
                    shapeSVG = document.createElementNS(svgNS, 'rect');
                    shapeSVG.setAttribute('width', width);
                    shapeSVG.setAttribute('height', height);
                    shapeSVG.setAttribute('rx', '20');
                    shapePathData = `M20,0 H${width-20} Q${width},0 ${width},20 V${height-20} Q${width},${height} ${width-20},${height} H20 Q0,${height} 0,${height-20} V20 Q0,0 20,0 Z`;
                    break;
                case 'data': // Parallelogram
                    shapeSVG = document.createElementNS(svgNS, 'polygon');
                    const offset = 15;
                    const pPoints = `${offset},0 ${width},0 ${width-offset},${height} 0,${height}`;
                    shapeSVG.setAttribute('points', pPoints);
                    shapePathData = `M${offset},0 L${width},0 L${width-offset},${height} L0,${height} Z`;
                    break;
                 case 'rectangle':
                    shapeSVG = document.createElementNS(svgNS, 'rect');
                    shapeSVG.setAttribute('width', width);
                    shapeSVG.setAttribute('height', height);
                    shapeSVG.setAttribute('rx', '4');
                    shapePathData = `M0,0 L${width},0 L${width},${height} L0,${height} Z`;
                    break;
                case 'circle':
                    shapeSVG = document.createElementNS(svgNS, 'circle');
                    shapeSVG.setAttribute('cx', width/2);
                    shapeSVG.setAttribute('cy', height/2);
                    shapeSVG.setAttribute('r', Math.min(width, height)/2);
                    shapePathData = `M${width/2},${height/2} m-${Math.min(width, height)/2},0 a${Math.min(width, height)/2},${Math.min(width, height)/2} 0 1,0 ${Math.min(width, height)},0 a${Math.min(width, height)/2},${Math.min(width, height)/2} 0 1,0 -${Math.min(width, height)},0`;
                    break;
                case 'triangle':
                    shapeSVG = document.createElementNS(svgNS, 'polygon');
                    shapeSVG.setAttribute('points', `${width/2},0 ${width},${height} 0,${height}`);
                    shapePathData = `M${width/2},0 L${width},${height} L0,${height} Z`;
                    break;
                case 'diamond':
                    shapeSVG = document.createElementNS(svgNS, 'polygon');
                    shapeSVG.setAttribute('points', `${width/2},0 ${width},${height/2} ${width/2},${height} 0,${height/2}`);
                    shapePathData = `M${width/2},0 L${width},${height/2} L${width/2},${height} L0,${height/2} Z`;
                    break;
                case 'arrow':
                    shapeSVG = document.createElementNS(svgNS, 'path');
                    shapeSVG.setAttribute('d', 'M10,30 L60,30 L60,10 L90,40 L60,70 L60,50 L10,50 Z');
                    shapePathData = 'M10,30 L60,30 L60,10 L90,40 L60,70 L60,50 L10,50 Z';
                    svg.style.width = '100px';
                    svg.style.height = '80px';
                    break;
                case 'cloud':
                    shapeSVG = document.createElementNS(svgNS, 'path');
                    shapeSVG.setAttribute('d', 'M25,60 Q15,60 15,50 Q15,35 30,35 Q30,25 40,25 Q50,25 55,30 Q65,20 75,25 Q85,30 85,40 Q90,45 90,55 Q90,65 80,65 Q85,70 75,70 Q70,75 60,70 Q50,75 40,70 Q30,75 25,70 Q15,70 20,65 Z');
                    shapePathData = 'M25,60 Q15,60 15,50 Q15,35 30,35 Q30,25 40,25 Q50,25 55,30 Q65,20 75,25 Q85,30 85,40 Q90,45 90,55 Q90,65 80,65 Q85,70 75,70 Q70,75 60,70 Q50,75 40,70 Q30,75 25,70 Q15,70 20,65 Z';
                    svg.style.width = '100px';
                    svg.style.height = '80px';
                    break;
                case 'sticky':
                    shapeSVG = document.createElementNS(svgNS, 'path');
                    shapeSVG.setAttribute('d', 'M0,15 Q0,0 15,0 L85,0 Q100,0 100,15 L100,85 Q100,100 85,100 L15,100 Q0,100 0,85 Z');
                    shapePathData = 'M0,15 Q0,0 15,0 L85,0 Q100,0 100,15 L100,85 Q100,100 85,100 L15,100 Q0,100 0,85 Z';
                    svg.style.width = '100px';
                    svg.style.height = '100px';
                    state.shapeSettings.fillColor = '#d7ba7d'; // Override color
                    break;
            }

            shapeSVG.setAttribute('fill', state.shapeSettings.fillColor);
            shapeSVG.setAttribute('stroke', state.shapeSettings.strokeColor);
            shapeSVG.setAttribute('stroke-width', state.shapeSettings.strokeWidth);
            shapeSVG.setAttribute('class', 'flowchart-shape');
            svg.appendChild(shapeSVG);

            // Store connection points (simplified: center of edges)
            const connectionPoints = [];
            if (['process', 'terminator', 'data', 'rectangle'].includes(state.shapeSettings.type)) {
                 connectionPoints.push({x: width/2, y: 0, id: 'top'});
                 connectionPoints.push({x: width, y: height/2, id: 'right'});
                 connectionPoints.push({x: width/2, y: height, id: 'bottom'});
                 connectionPoints.push({x: 0, y: height/2, id: 'left'});
            } else if (state.shapeSettings.type === 'decision') {
                 connectionPoints.push({x: width/2, y: 0, id: 'top'});
                 connectionPoints.push({x: width, y: height/2, id: 'right'});
                 connectionPoints.push({x: width/2, y: height, id: 'bottom'});
                 connectionPoints.push({x: 0, y: height/2, id: 'left'});
            } else if (state.shapeSettings.type === 'circle') {
                 connectionPoints.push({x: width/2, y: 0, id: 'top'});
                 connectionPoints.push({x: width, y: height/2, id: 'right'});
                 connectionPoints.push({x: width/2, y: height, id: 'bottom'});
                 connectionPoints.push({x: 0, y: height/2, id: 'left'});
            } else {
                connectionPoints.push({x: width/2, y: 0, id: 'top'});
                connectionPoints.push({x: width, y: height/2, id: 'right'});
                connectionPoints.push({x: width/2, y: height, id: 'bottom'});
                connectionPoints.push({x: 0, y: height/2, id: 'left'});
            }

            // Create small visual connection points
            connectionPoints.forEach(point => {
                const circle = document.createElementNS(svgNS, 'circle');
                circle.setAttribute('class', 'connector-point');
                circle.setAttribute('cx', point.x);
                circle.setAttribute('cy', point.y);
                circle.setAttribute('r', 4);
                circle.setAttribute('data-point-id', point.id);
                circle.style.display = 'none';
                svg.appendChild(circle);
            });

            const element = {
                type: 'shape',
                element: svg,
                id: svg.id,
                x: snapToGrid(x),
                y: snapToGrid(y),
                width: width,
                height: height,
                shapeType: state.shapeSettings.type,
                fillColor: state.shapeSettings.fillColor,
                strokeColor: state.shapeSettings.strokeColor,
                strokeWidth: state.shapeSettings.strokeWidth,
                connectionPoints: connectionPoints,
                pathData: shapePathData
            };

            state.canvas.elements.push(element);
            document.getElementById('canvas').appendChild(svg);

            // Show connection points on hover
            svg.addEventListener('mouseenter', () => {
                if (!state.canvas.isCreatingConnector) {
                    svg.querySelectorAll('.connector-point').forEach(p => p.style.display = 'block');
                }
            });
            svg.addEventListener('mouseleave', () => {
                svg.querySelectorAll('.connector-point').forEach(p => p.style.display = 'none');
            });

            svg.addEventListener('mousedown', (e) => {
                if (state.currentTool === 'select') {
                    const isMulti = e.shiftKey;
                    selectElement(element, isMulti);
                    if (!isMulti && !element.isLocked) startDragging(e, element);
                    e.stopPropagation();
                } else if (state.currentTool === 'connector') {
                    startConnectorFromShape(e, element);
                    e.stopPropagation();
                }
            });

            selectElement(element);
            saveToHistory("Create Shape");
        }

         function updateShapeSVG(shapeElement) {
            const svg = shapeElement.element;
            const width = shapeElement.width;
            const height = shapeElement.height;
            svg.style.width = width + 'px';
            svg.style.height = height + 'px';

            const shape = svg.querySelector('.flowchart-shape');
            if (!shape) return;

            switch(shapeElement.shapeType) {
                case 'process':
                case 'rectangle':
                    shape.setAttribute('width', width);
                    shape.setAttribute('height', height);
                    break;
                case 'terminator':
                    shape.setAttribute('width', width);
                    shape.setAttribute('height', height);
                    break;
                case 'decision':
                    const points = `${width/2},0 ${width},${height/2} ${width/2},${height} 0,${height/2}`;
                    shape.setAttribute('points', points);
                    break;
                case 'data':
                    const offset = Math.min(15, width / 4);
                    const pPoints = `${offset},0 ${width},0 ${width-offset},${height} 0,${height}`;
                    shape.setAttribute('points', pPoints);
                    break;
                case 'circle':
                    shape.setAttribute('cx', width/2);
                    shape.setAttribute('cy', height/2);
                    shape.setAttribute('r', Math.min(width, height)/2);
                    break;
                case 'triangle':
                    shape.setAttribute('points', `${width/2},0 ${width},${height} 0,${height}`);
                    break;
                case 'diamond':
                    shape.setAttribute('points', `${width/2},0 ${width},${height/2} ${width/2},${height} 0,${height/2}`);
                    break;
                // Arrow, Cloud, Sticky would need more complex path updates, skipped for now
            }
        }


        // --- Connector Tool ---
        function startConnectorFromShape(e, shapeElement) {
            const rect = shapeElement.element.getBoundingClientRect();
            const canvasRect = document.getElementById('canvas').getBoundingClientRect();

            const localX = (e.clientX - canvasRect.left - state.canvas.panX) / state.canvas.zoom - shapeElement.x;
            const localY = (e.clientY - canvasRect.top - state.canvas.panY) / state.canvas.zoom - shapeElement.y;

            let closestPoint = null;
            let minDist = Infinity;
            shapeElement.connectionPoints.forEach(point => {
                const dx = point.x - localX;
                const dy = point.y - localY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < minDist && dist < 20) {
                    minDist = dist;
                    closestPoint = point;
                }
            });

            if (closestPoint) {
                state.canvas.isCreatingConnector = true;
                state.canvas.connectorStartPoint = {
                    elementId: shapeElement.id,
                    pointId: closestPoint.id,
                    x: shapeElement.x + closestPoint.x,
                    y: shapeElement.y + closestPoint.y
                };
                const svgNS = "http://www.w3.org/2000/svg";
                const tempSVG = document.createElementNS(svgNS, 'svg');
                tempSVG.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5;';
                tempSVG.setAttribute('class', 'canvas-element');
                const tempPath = document.createElementNS(svgNS, 'path');
                tempPath.setAttribute('d', `M ${state.canvas.connectorStartPoint.x} ${state.canvas.connectorStartPoint.y} L ${state.canvas.connectorStartPoint.x} ${state.canvas.connectorStartPoint.y}`);
                tempPath.setAttribute('fill', 'none');
                tempPath.setAttribute('stroke', state.connectorSettings.strokeColor);
                tempPath.setAttribute('stroke-width', state.connectorSettings.strokeWidth);
                if (state.connectorSettings.arrowheads === 'end' || state.connectorSettings.arrowheads === 'both') {
                    tempPath.setAttribute('marker-end', 'url(#arrowhead)');
                }
                tempSVG.appendChild(tempPath);
                document.getElementById('canvas').appendChild(tempSVG);
                state.canvas.tempConnector = tempSVG;
            }
        }

        function updateTempConnector(endX, endY) {
            if (!state.canvas.tempConnector || !state.canvas.connectorStartPoint) return;
            const path = state.canvas.tempConnector.querySelector('path');
            if (path) {
                const startX = state.canvas.connectorStartPoint.x;
                const startY = state.canvas.connectorStartPoint.y;
                const midX = (startX + endX) / 2;
                const pathData = `M ${startX} ${startY} L ${midX} ${startY} L ${midX} ${endY} L ${endX} ${endY}`;
                path.setAttribute('d', pathData);
            }
        }

        function finishConnector(endX, endY, endElement = null, endPointId = null) {
             if (!state.canvas.connectorStartPoint) return;

            let endConnectorPoint = { x: endX, y: endY };
            if (endElement && endPointId) {
                const endPoint = endElement.connectionPoints.find(p => p.id === endPointId);
                if (endPoint) {
                    endConnectorPoint.x = endElement.x + endPoint.x;
                    endConnectorPoint.y = endElement.y + endPoint.y;
                }
            }

            const svgNS = "http://www.w3.org/2000/svg";
            const connectorSVG = document.createElementNS(svgNS, 'svg');
            connectorSVG.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;';
            connectorSVG.setAttribute('class', 'canvas-element connector-element');
            connectorSVG.setAttribute('id', generateId());

            const path = document.createElementNS(svgNS, 'path');
            path.setAttribute('class', 'connector-path');
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke', state.connectorSettings.strokeColor);
            path.setAttribute('stroke-width', state.connectorSettings.strokeWidth);

            if (state.connectorSettings.arrowheads === 'end' || state.connectorSettings.arrowheads === 'both') {
                path.setAttribute('marker-end', 'url(#arrowhead)');
            }
            if (state.connectorSettings.arrowheads === 'start' || state.connectorSettings.arrowheads === 'both') {
                path.setAttribute('marker-start', 'url(#arrowhead)');
            }

            connectorSVG.appendChild(path);

            const startX = state.canvas.connectorStartPoint.x;
            const startY = state.canvas.connectorStartPoint.y;
            const endXFinal = endConnectorPoint.x;
            const endYFinal = endConnectorPoint.y;
            const midX = (startX + endXFinal) / 2;
            const pathData = `M ${startX} ${startY} L ${midX} ${startY} L ${midX} ${endYFinal} L ${endXFinal} ${endYFinal}`;
            path.setAttribute('d', pathData);

            const connectorElement = {
                type: 'connector',
                element: connectorSVG,
                id: connectorSVG.id,
                startElementId: state.canvas.connectorStartPoint.elementId,
                endElementId: endElement ? endElement.id : null,
                startPoint: { x: startX, y: startY },
                endPoint: { x: endXFinal, y: endYFinal },
                label: '',
                pathData: pathData,
                strokeColor: state.connectorSettings.strokeColor,
                strokeWidth: state.connectorSettings.strokeWidth,
                arrowheads: state.connectorSettings.arrowheads
            };

            state.canvas.elements.push(connectorElement);
            document.getElementById('canvas').appendChild(connectorSVG);

            path.style.pointerEvents = 'all';
            path.style.cursor = 'pointer';
            path.addEventListener('mousedown', (e) => {
                if (state.currentTool === 'select') {
                    const isMulti = e.shiftKey;
                    selectElement(connectorElement, isMulti);
                    e.stopPropagation();
                }
            });

            path.addEventListener('dblclick', (e) => {
                createConnectorLabel(connectorElement, e.clientX, e.clientY);
                e.stopPropagation();
            });

            selectElement(connectorElement);
            saveToHistory("Create Connector");

            state.canvas.isCreatingConnector = false;
            state.canvas.connectorStartPoint = null;
            if (state.canvas.tempConnector) {
                state.canvas.tempConnector.remove();
                state.canvas.tempConnector = null;
            }
        }

        function createConnectorLabel(connectorElement, clientX, clientY) {
            const label = prompt('Enter label:', connectorElement.label || '');
            if (label !== null) {
                connectorElement.label = label;
                updateConnectorLabel(connectorElement, clientX, clientY);
                saveToHistory("Edit Connector Label");
            }
        }

        function updateConnectorLabel(connectorElement, clientX, clientY) {
            let labelEl = connectorElement.element.querySelector('.connector-label');
            if (labelEl) {
                labelEl.remove();
                const bg = labelEl.previousElementSibling;
                if (bg && bg.tagName === 'rect') bg.remove();
            }

            if (connectorElement.label) {
                const svgNS = "http://www.w3.org/2000/svg";
                if (!labelEl) {
                    labelEl = document.createElementNS(svgNS, 'text');
                    labelEl.setAttribute('class', 'connector-label');
                    connectorElement.element.appendChild(labelEl);

                    labelEl.addEventListener('mousedown', (e) => {
                        if (state.currentTool === 'select') {
                            const isMulti = e.shiftKey;
                            selectElement(connectorElement, isMulti);
                            e.stopPropagation();
                        }
                    });
                    labelEl.addEventListener('dblclick', (e) => {
                        e.stopPropagation();
                        createConnectorLabel(connectorElement, e.clientX, e.clientY);
                    });
                }

                labelEl.textContent = connectorElement.label;
                const canvasRect = document.getElementById('canvas').getBoundingClientRect();
                labelEl.setAttribute('x', (clientX - canvasRect.left - state.canvas.panX) / state.canvas.zoom);
                labelEl.setAttribute('y', (clientY - canvasRect.top - state.canvas.panY) / state.canvas.zoom - 5);

                const bbox = labelEl.getBBox();
                const padding = 2;
                let bg = connectorElement.element.querySelector('rect'); // Reuse or create
                if (!bg) {
                    bg = document.createElementNS(svgNS, 'rect');
                    connectorElement.element.insertBefore(bg, labelEl);
                }
                bg.setAttribute('x', bbox.x - padding);
                bg.setAttribute('y', bbox.y - padding);
                bg.setAttribute('width', bbox.width + 2 * padding);
                bg.setAttribute('height', bbox.height + 2 * padding);
                bg.setAttribute('fill', 'var(--bg-primary)');
                bg.setAttribute('rx', '2');
            }
        }

        function updateConnectedConnectors(shapeElement) {
            state.canvas.elements.forEach(el => {
                if (el.type === 'connector' && (el.startElementId === shapeElement.id || el.endElementId === shapeElement.id)) {
                    let updatedStartPoint = el.startPoint;
                    let updatedEndPoint = el.endPoint;

                    if (el.startElementId === shapeElement.id) {
                        const startPointDef = shapeElement.connectionPoints.find(p => p.id === 'center'); // Simplified
                        if (startPointDef) {
                            updatedStartPoint = {
                                x: shapeElement.x + startPointDef.x,
                                y: shapeElement.y + startPointDef.y
                            };
                        } else {
                            // Fallback to center if no specific point
                            updatedStartPoint = {
                                x: shapeElement.x + shapeElement.width / 2,
                                y: shapeElement.y + shapeElement.height / 2
                            };
                        }
                    }
                    if (el.endElementId === shapeElement.id) {
                        const endPointDef = shapeElement.connectionPoints.find(p => p.id === 'center'); // Simplified
                         if (endPointDef) {
                            updatedEndPoint = {
                                x: shapeElement.x + endPointDef.x,
                                y: shapeElement.y + endPointDef.y
                            };
                        } else {
                            updatedEndPoint = {
                                x: shapeElement.x + shapeElement.width / 2,
                                y: shapeElement.y + shapeElement.height / 2
                            };
                        }
                    }

                    const path = el.element.querySelector('.connector-path');
                    if (path) {
                        const startX = updatedStartPoint.x;
                        const startY = updatedStartPoint.y;
                        const endX = updatedEndPoint.x;
                        const endY = updatedEndPoint.y;
                        const midX = (startX + endX) / 2;
                        const newPathData = `M ${startX} ${startY} L ${midX} ${startY} L ${midX} ${endY} L ${endX} ${endY}`;
                        path.setAttribute('d', newPathData);
                        el.startPoint = updatedStartPoint;
                        el.endPoint = updatedEndPoint;
                        el.pathData = newPathData;
                    }
                }
            });
        }


        // --- Code Snippet Tool ---
        function createCodeElement(x, y) {
            const pre = document.createElement('pre');
            const code = document.createElement('code');
            pre.className = 'code-element canvas-element';
            pre.style.left = snapToGrid(x) + 'px';
            pre.style.top = snapToGrid(y) + 'px';

            let defaultContent = '';
            switch(state.codeSettings.language) {
                case 'javascript':
                    defaultContent = `// JavaScript Example\nfunction greet(name) {\n  console.log("Hello, " + name + "!");\n}\ngreet("CodeCanvas");`;
                    break;
                case 'python':
                    defaultContent = `# Python Example\ndef greet(name):\n    print(f"Hello, {name}!")\n\ngreet("CodeCanvas")`;
                    break;
                case 'html':
                    defaultContent = `<!-- HTML Example -->\n<div class="container">\n  <h1>Hello, CodeCanvas!</h1>\n</div>`;
                    break;
                case 'css':
                    defaultContent = `/* CSS Example */\n.container {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}`;
                    break;
                default:
                    defaultContent = `// ${state.codeSettings.language} code\n// Add your code here`;
            }
            code.textContent = defaultContent;

            const languageClass = `language-${state.codeSettings.language}`;
            code.classList.add(languageClass);
            if (typeof Prism !== 'undefined') {
                Prism.highlightElement(code);
            }

            pre.appendChild(code);

            const element = {
                type: 'code',
                element: pre,
                id: generateId(),
                x: snapToGrid(x),
                y: snapToGrid(y),
                width: 300,
                height: 150,
                language: state.codeSettings.language
            };
            element.element.style.width = element.width + 'px';
            element.element.style.height = element.height + 'px';

            state.canvas.elements.push(element);
            document.getElementById('canvas').appendChild(pre);

            pre.addEventListener('mousedown', (e) => {
                if (state.currentTool === 'select') {
                    const isMulti = e.shiftKey;
                    selectElement(element, isMulti);
                    if (!isMulti && !element.isLocked) startDragging(e, element);
                    e.stopPropagation();
                }
            });

            // Make code editable
            code.setAttribute('contenteditable', 'true');
            code.addEventListener('blur', () => {
                saveToHistory("Edit Code");
            });
            code.addEventListener('input', () => {
                 // Update syntax highlighting
                if (typeof Prism !== 'undefined') {
                    const newCode = document.createElement('code');
                    newCode.className = code.className;
                    newCode.textContent = code.textContent;
                    Prism.highlightElement(newCode);
                    // Swap nodes to avoid losing focus
                    pre.replaceChild(newCode, code);
                }
            });

            selectElement(element);
            saveToHistory("Create Code Snippet");
        }

        function copyCodeToClipboard() {
             if (state.canvas.selectedElements.length !== 1) return;
             const element = state.canvas.selectedElements[0];
             if (element.type !== 'code') return;

             const code = element.element.querySelector('code');
             if (code) {
                navigator.clipboard.writeText(code.textContent).then(() => {
                    showNotification('Code copied to clipboard!');
                }).catch(err => {
                    console.error('Failed to copy: ', err);
                    showNotification('Failed to copy code.', true);
                });
             }
        }


        // --- Event Handlers ---
        function handleCanvasMouseDown(e) {
            if (e.button !== 0) return; // Only left mouse button
            const rect = e.currentTarget.getBoundingClientRect();
            const x = (e.clientX - rect.left - state.canvas.panX) / state.canvas.zoom;
            const y = (e.clientY - rect.top - state.canvas.panY) / state.canvas.zoom;
            state.canvas.startPoint = { x, y };

            if (state.canvas.isCreatingConnector) {
                const clickedElement = getElementAtPosition(e.clientX, e.clientY);
                if (clickedElement && clickedElement.type === 'shape' && clickedElement.id !== state.canvas.connectorStartPoint.elementId) {
                    const localX = x - clickedElement.x;
                    const localY = y - clickedElement.y;
                    let endPoint = null;
                    let minDist = Infinity;
                    clickedElement.connectionPoints.forEach(point => {
                        const dx = point.x - localX;
                        const dy = point.y - localY;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < minDist && dist < 20) {
                            minDist = dist;
                            endPoint = point;
                        }
                    });
                    if (endPoint) {
                        finishConnector(x, y, clickedElement, endPoint.id);
                    } else {
                        finishConnector(x, y);
                    }
                } else {
                    finishConnector(x, y);
                }
                return;
            }

            switch(state.currentTool) {
                case 'select':
                    const clickedElement = getElementAtPosition(e.clientX, e.clientY);
                    if (clickedElement) {
                        const isMulti = e.shiftKey;
                        selectElement(clickedElement, isMulti);
                        if (!isMulti && !clickedElement.isLocked) startDragging(e, clickedElement);
                    } else {
                        if (!e.shiftKey) clearSelection();
                    }
                    break;
                case 'brush':
                    startDrawing(snapToGrid(x), snapToGrid(y));
                    break;
                case 'eraser':
                    startErasing(snapToGrid(x), snapToGrid(y));
                    break;
                case 'text':
                    createTextElement(snapToGrid(x), snapToGrid(y));
                    break;
                case 'shape':
                    createShapeElement(snapToGrid(x), snapToGrid(y));
                    break;
                case 'connector':
                    // Handled by shape click
                    break;
                case 'code':
                    createCodeElement(snapToGrid(x), snapToGrid(y));
                    break;
            }
        }

        function handleCanvasMouseMove(e) {
            const rect = e.currentTarget.getBoundingClientRect();
            const x = (e.clientX - rect.left - state.canvas.panX) / state.canvas.zoom;
            const y = (e.clientY - rect.top - state.canvas.panY) / state.canvas.zoom;

            if (state.canvas.isPanning && state.canvas.startPoint) {
                const dx = (x - state.canvas.startPoint.x) * state.canvas.zoom;
                const dy = (y - state.canvas.startPoint.y) * state.canvas.zoom;
                state.canvas.panX += dx;
                state.canvas.panY += dy;
                state.canvas.startPoint = { x, y };
                updateCanvasTransform();
                return;
            }

            if (state.canvas.isDrawing && state.canvas.currentPath) {
                if (state.currentTool === 'brush') {
                    drawLine(state.canvas.startPoint.x, state.canvas.startPoint.y, x, y);
                } else if (state.currentTool === 'eraser') {
                    eraseLine(state.canvas.startPoint.x, state.canvas.startPoint.y, x, y);
                }
                state.canvas.startPoint = { x, y };
            }

            if (state.canvas.isCreatingConnector && state.canvas.tempConnector) {
                updateTempConnector(x, y);
            }
        }

        function handleCanvasMouseUp(e) {
            if (state.canvas.isDrawing) {
                state.canvas.isDrawing = false;
                if (state.canvas.currentPath) {
                    saveToHistory("Draw");
                    state.canvas.currentPath = null;
                }
            }
            if (state.canvas.isPanning) {
                state.canvas.isPanning = false;
                e.currentTarget.style.cursor = getCursorForTool(state.currentTool);
            }
            state.canvas.startPoint = null;
        }

        function handleCanvasWheel(e) {
            e.preventDefault();
            // Check if cursor is over the canvas container
            if (!document.getElementById('canvasContainer').contains(e.target)) return;

            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            zoom(delta, e.clientX, e.clientY);
        }

        // Panning with Spacebar
        function handleKeyDown(e) {
             // Prevent default for keys that have actions, but allow input in text fields
            const isInputField = e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.contentEditable === 'true';
            if (isInputField && e.target.id !== 'zoomLevelInput') return;

            const isCtrlCmd = e.ctrlKey || e.metaKey;

            if (!isCtrlCmd) {
                switch(e.key.toLowerCase()) {
                    case 'v': selectTool('select'); e.preventDefault(); break;
                    case 'b': selectTool('brush'); e.preventDefault(); break;
                    case 'e': selectTool('eraser'); e.preventDefault(); break;
                    case 't': selectTool('text'); e.preventDefault(); break;
                    case 's': if(e.shiftKey) { selectTool('shape'); e.preventDefault(); } break;
                    case 'c': selectTool('connector'); e.preventDefault(); break;
                    case 'n': if(e.shiftKey) { showNewProjectModal(); e.preventDefault(); } break;
                    case 'o': if(e.shiftKey) { showProjectModal(); e.preventDefault(); } break;
                    case ' ': // Spacebar for panning
                        if (!state.canvas.isSpacePanning) {
                            state.canvas.isSpacePanning = true;
                            document.getElementById('canvasContainer').style.cursor = 'grab';
                        }
                        e.preventDefault();
                        break;
                    case 'delete':
                    case 'backspace':
                        if (state.canvas.selectedElements.length > 0 && !isInputField) {
                            e.preventDefault();
                            deleteSelectedElements();
                        }
                        break;
                    case 'escape':
                        clearSelection();
                        state.canvas.isCreatingConnector = false;
                        if (state.canvas.tempConnector) {
                            state.canvas.tempConnector.remove();
                            state.canvas.tempConnector = null;
                        }
                        break;
                }
                // Nudge selected elements with arrow keys
                if (state.canvas.selectedElements.length > 0 && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                    e.preventDefault();
                    const step = e.shiftKey ? 10 : 1;
                    const dx = e.key === 'ArrowLeft' ? -step : e.key === 'ArrowRight' ? step : 0;
                    const dy = e.key === 'ArrowUp' ? -step : e.key === 'ArrowDown' ? step : 0;
                    let moved = false;
                    state.canvas.selectedElements.forEach(el => {
                        if (!el.isLocked) {
                            el.x = snapToGrid(el.x + dx);
                            el.y = snapToGrid(el.y + dy);
                            el.element.style.left = el.x + 'px';
                            el.element.style.top = el.y + 'px';
                            moved = true;
                            if (el.type === 'shape') {
                                updateConnectedConnectors(el);
                            }
                        }
                    });
                    if (moved) {
                        saveToHistory("Nudge Elements");
                    }
                }
            }

            if (isCtrlCmd) {
                if (e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    undo();
                }
                if ((e.key === 'y') || (e.key === 'z' && e.shiftKey)) {
                    e.preventDefault();
                    redo();
                }
                if (e.key === 's') {
                    e.preventDefault();
                    saveCurrentProject();
                }
                if (e.key === 'd') {
                    e.preventDefault();
                    duplicateSelectedElements();
                }
                if (e.key === '=' || e.key === '+') {
                    e.preventDefault();
                    zoom(1.2, window.innerWidth/2, window.innerHeight/2);
                }
                if (e.key === '-') {
                    e.preventDefault();
                    zoom(0.8, window.innerWidth/2, window.innerHeight/2);
                }
                if (e.key === '0') {
                    e.preventDefault();
                    resetZoom();
                }
                if (e.key === '1') {
                    e.preventDefault();
                    fitToScreen();
                }
                if (e.key === 'e' && e.shiftKey) {
                     e.preventDefault();
                     exportProject();
                }
            }
        }

        function handleKeyUp(e) {
            if (e.code === 'Space') {
                state.canvas.isSpacePanning = false;
                if (!state.canvas.isPanning) {
                    document.getElementById('canvasContainer').style.cursor = getCursorForTool(state.currentTool);
                }
            }
        }

        function handleCanvasMouseDownForPanning(e) {
             // Middle mouse or Space+Left for panning
            if (e.button === 1 || (e.button === 0 && state.canvas.isSpacePanning)) {
                state.canvas.isPanning = true;
                document.getElementById('canvasContainer').style.cursor = 'grabbing';
                const rect = document.getElementById('canvasContainer').getBoundingClientRect();
                const x = (e.clientX - rect.left - state.canvas.panX) / state.canvas.zoom;
                const y = (e.clientY - rect.top - state.canvas.panY) / state.canvas.zoom;
                state.canvas.startPoint = { x, y };
                e.preventDefault();
            }
        }


        function getElementAtPosition(clientX, clientY) {
            const elements = [...document.elementsFromPoint(clientX, clientY)];
            for (const el of elements) {
                const canvasEl = state.canvas.elements.find(e => e.element === el || e.element.contains(el));
                if (canvasEl) {
                    return canvasEl;
                }
            }
            return null;
        }

        // --- Project Management ---
        function saveProjects() {
            try {
                localStorage.setItem('codecanvas_projects', JSON.stringify(state.projects));
                if(state.currentProject) {
                    localStorage.setItem('codecanvas_current', state.currentProject);
                }
            } catch(e) {
                console.error('Failed to save projects:', e);
                showNotification('Error saving projects.', true);
            }
        }

        function loadProjects() {
             const currentId = localStorage.getItem('codecanvas_current');
             if (currentId && state.projects[currentId]) {
                 loadProject(currentId);
             } else if (Object.keys(state.projects).length > 0) {
                  const firstProjectId = Object.keys(state.projects)[0];
                  loadProject(firstProjectId);
             } else {
                 createNewProject('Untitled Project');
             }
        }

        function createNewProject(name) {
            const projectId = 'project_' + Date.now();
            const project = {
                id: projectId,
                name: name || 'Untitled Project',
                created: new Date().toISOString(),
                modified: new Date().toISOString(),
                canvas: {
                    elements: [],
                    zoom: 1,
                    panX: 0,
                    panY: 0
                }
            };
            state.projects[projectId] = project;
            state.currentProject = projectId;
            loadProject(projectId);
            saveProjects();
            return projectId;
        }

        function loadProject(projectId) {
            const project = state.projects[projectId];
            if (!project) return;

            clearSelection();
            state.canvas.elements.forEach(el => {
                 if (el.element && el.element.parentNode) {
                    el.element.parentNode.removeChild(el.element);
                }
            });
            state.canvas.elements = [];

            state.currentProject = projectId;
            document.getElementById('projectName').textContent = project.name;

            state.canvas.zoom = project.canvas.zoom || 1;
            state.canvas.panX = project.canvas.panX || 0;
            state.canvas.panY = project.canvas.panY || 0;
            updateCanvasTransform();
            updateZoomDisplay();

            if (project.canvas.elements) {
                project.canvas.elements.forEach(data => {
                    createElementFromData(data);
                });
            }
        }

        function createElementFromData(data) {
             let element, canvasElement;
            switch(data.type) {
                case 'drawing':
                    const parser = new DOMParser();
                    const svgDoc = parser.parseFromString(data.content, 'image/svg+xml');
                    element = svgDoc.documentElement;
                    if (element && element.tagName && element.tagName.toLowerCase() === 'svg') {
                        element.setAttribute('style', data.style);
                        element.setAttribute('class', 'canvas-element');
                        element.setAttribute('id', data.id);
                        canvasElement = {
                            type: 'drawing',
                            element: element,
                            id: data.id,
                            x: data.x,
                            y: data.y
                        };
                    }
                    break;
                case 'text':
                    element = document.createElement('textarea');
                    element.className = 'text-element canvas-element';
                    element.setAttribute('style', data.style);
                    element.value = data.content;
                    canvasElement = {
                        type: 'text',
                        element: element,
                        id: data.id,
                        x: data.x,
                        y: data.y,
                        width: data.width || 150,
                        height: data.height || 60
                    };
                    element.style.width = canvasElement.width + 'px';
                    element.style.height = canvasElement.height + 'px';
                    element.addEventListener('mousedown', (e) => {
                        if (state.currentTool === 'select') {
                            const isMulti = e.shiftKey;
                            selectElement(canvasElement, isMulti);
                            if (!isMulti && !canvasElement.isLocked) startDragging(e, canvasElement);
                            e.stopPropagation();
                        }
                    });
                    element.addEventListener('input', () => {
                        element.style.height = 'auto';
                        element.style.height = element.scrollHeight + 'px';
                        canvasElement.height = element.scrollHeight;
                        saveToHistory("Edit Text");
                    });
                    element.addEventListener('blur', saveToHistory);
                    break;
                case 'shape':
                    const svgNS = "http://www.w3.org/2000/svg";
                    element = document.createElementNS(svgNS, 'svg');
                    element.setAttribute('style', data.style);
                    element.innerHTML = data.content;
                    element.setAttribute('class', 'canvas-element shape-element');
                    element.setAttribute('id', data.id);
                    canvasElement = {
                        type: 'shape',
                        element: element,
                        id: data.id,
                        x: data.x,
                        y: data.y,
                        width: data.width || 100,
                        height: data.height || 60,
                        shapeType: data.attributes.shapeType,
                        fillColor: data.attributes.fillColor || '#4ec9b0',
                        strokeColor: data.attributes.strokeColor || '#ffffff',
                        strokeWidth: data.attributes.strokeWidth || 2,
                        connectionPoints: data.attributes.connectionPoints || [],
                        pathData: data.attributes.pathData || '',
                        isLocked: data.isLocked || false
                    };
                    if(canvasElement.isLocked) {
                        element.style.opacity = '0.7';
                        element.style.pointerEvents = 'none';
                    }
                    element.addEventListener('mouseenter', () => {
                        if (!state.canvas.isCreatingConnector) {
                            element.querySelectorAll('.connector-point').forEach(p => p.style.display = 'block');
                        }
                    });
                    element.addEventListener('mouseleave', () => {
                        element.querySelectorAll('.connector-point').forEach(p => p.style.display = 'none');
                    });
                    element.addEventListener('mousedown', (e) => {
                        if (state.currentTool === 'select') {
                            const isMulti = e.shiftKey;
                            selectElement(canvasElement, isMulti);
                            if (!isMulti && !canvasElement.isLocked) startDragging(e, canvasElement);
                            e.stopPropagation();
                        } else if (state.currentTool === 'connector') {
                            startConnectorFromShape(e, canvasElement);
                            e.stopPropagation();
                        }
                    });
                    break;
                case 'code':
                    element = document.createElement('pre');
                    const codeEl = document.createElement('code');
                    element.className = 'code-element canvas-element';
                    element.setAttribute('style', data.style);
                    codeEl.textContent = data.content;
                    const langClass = `language-${data.attributes.language || 'javascript'}`;
                    codeEl.classList.add(langClass);
                    if (typeof Prism !== 'undefined') {
                        Prism.highlightElement(codeEl);
                    }
                    element.appendChild(codeEl);
                    canvasElement = {
                        type: 'code',
                        element: element,
                        id: data.id,
                        x: data.x,
                        y: data.y,
                        width: data.width || 300,
                        height: data.height || 150,
                        language: data.attributes.language || 'javascript',
                        isLocked: data.isLocked || false
                    };
                    element.style.width = canvasElement.width + 'px';
                    element.style.height = canvasElement.height + 'px';
                    if(canvasElement.isLocked) {
                        element.style.opacity = '0.7';
                        element.style.pointerEvents = 'none';
                    }
                    element.addEventListener('mousedown', (e) => {
                        if (state.currentTool === 'select') {
                            const isMulti = e.shiftKey;
                            selectElement(canvasElement, isMulti);
                            if (!isMulti && !canvasElement.isLocked) startDragging(e, canvasElement);
                            e.stopPropagation();
                        }
                    });
                    codeEl.setAttribute('contenteditable', 'true');
                    codeEl.addEventListener('blur', () => { saveToHistory("Edit Code"); });
                    codeEl.addEventListener('input', () => {
                         if (typeof Prism !== 'undefined') {
                            const newCode = document.createElement('code');
                            newCode.className = codeEl.className;
                            newCode.textContent = codeEl.textContent;
                            Prism.highlightElement(newCode);
                            element.replaceChild(newCode, codeEl);
                        }
                    });
                    break;
                case 'connector':
                    const connSvgNS = "http://www.w3.org/2000/svg";
                    element = document.createElementNS(connSvgNS, 'svg');
                    element.setAttribute('style', data.style);
                    element.innerHTML = data.content;
                    element.setAttribute('class', 'canvas-element connector-element');
                    element.setAttribute('id', data.id);
                    canvasElement = {
                        type: 'connector',
                        element: element,
                        id: data.id,
                        x: data.x,
                        y: data.y,
                        startElementId: data.attributes.startElementId,
                        endElementId: data.attributes.endElementId,
                        startPoint: data.attributes.startPoint,
                        endPoint: data.attributes.endPoint,
                        label: data.attributes.label,
                        pathData: data.attributes.pathData,
                        strokeColor: data.attributes.strokeColor || '#cccccc',
                        strokeWidth: data.attributes.strokeWidth || 2,
                        arrowheads: data.attributes.arrowheads || 'end',
                        isLocked: data.isLocked || false
                    };
                    if(canvasElement.isLocked) {
                        element.style.opacity = '0.7';
                        element.style.pointerEvents = 'none';
                    }
                    const pathEl = element.querySelector('.connector-path');
                    if (pathEl) {
                        pathEl.style.pointerEvents = 'all';
                        pathEl.style.cursor = 'pointer';
                        pathEl.addEventListener('mousedown', (e) => {
                            if (state.currentTool === 'select') {
                                const isMulti = e.shiftKey;
                                selectElement(canvasElement, isMulti);
                                e.stopPropagation();
                            }
                        });
                    }
                    const labelEl = element.querySelector('.connector-label');
                    if (labelEl) {
                         labelEl.addEventListener('mousedown', (e) => {
                            if (state.currentTool === 'select') {
                                const isMulti = e.shiftKey;
                                selectElement(canvasElement, isMulti);
                                e.stopPropagation();
                            }
                        });
                        labelEl.addEventListener('dblclick', (e) => {
                            e.stopPropagation();
                            createConnectorLabel(canvasElement, e.clientX, e.clientY);
                        });
                    }
                    break;
            }
            if (element) {
                document.getElementById('canvas').appendChild(element);
                state.canvas.elements.push(canvasElement);
            }
            return canvasElement; // Return the created element object
        }


        function saveCurrentProject() {
            if (!state.currentProject) return;
            const project = state.projects[state.currentProject];
            if (!project) return;

            project.modified = new Date().toISOString();
            project.canvas = {
                elements: state.canvas.elements.map(el => serializeElement(el)),
                zoom: state.canvas.zoom,
                panX: state.canvas.panX,
                panY: state.canvas.panY
            };

            saveProjects();
            showNotification('Project saved!');
        }

        function exportProject() {
            if (!state.currentProject) return;
            const project = state.projects[state.currentProject];
            if (!project) return;

            const filename = `${project.name.replace(/[^a-zA-Z0-9_\-.]/g, '_')}.codecanvas`;
            const dataStr = JSON.stringify(project, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            showNotification('Project exported!');
        }

        function importProject() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.codecanvas,.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const projectData = JSON.parse(e.target.result);
                        if (!projectData.name || !projectData.id) {
                            throw new Error('Invalid project file structure.');
                        }
                        // Assign a new ID to avoid conflicts
                        projectData.id = 'project_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                        projectData.created = projectData.created || new Date().toISOString();
                        projectData.modified = new Date().toISOString();

                        state.projects[projectData.id] = projectData;
                        loadProject(projectData.id);
                        saveProjects();
                        showNotification('Project imported successfully!');
                    } catch(err) {
                        console.error('Import error:', err);
                        showNotification('Failed to import project: ' + (err.message || 'Invalid file format'), true);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        function deleteProject(projectId) {
             if (confirm('Are you sure you want to delete this project? This cannot be undone.')) {
                delete state.projects[projectId];
                if (state.currentProject === projectId) {
                    state.currentProject = null;
                    clearSelection();
                    state.canvas.elements.forEach(el => {
                         if (el.element && el.element.parentNode) {
                            el.element.parentNode.removeChild(el.element);
                        }
                    });
                    state.canvas.elements = [];
                    document.getElementById('projectName').textContent = 'Untitled Project';
                    setTimeout(() => createNewProject('Untitled Project'), 10);
                }
                saveProjects();
                showProjectModal();
                showNotification('Project deleted.');
             }
        }

        // --- UI Functions ---
        function showNewProjectModal() {
            document.getElementById('newProjectModal').classList.add('active');
            document.getElementById('newProjectName').focus();
        }

        function showProjectModal() {
            const modal = document.getElementById('projectModal');
            const list = document.getElementById('projectList');
            list.innerHTML = '';

            if (Object.keys(state.projects).length === 0) {
                list.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-secondary);">No projects found.</div>';
            } else {
                // Sort by modified date, newest first
                Object.values(state.projects).sort((a, b) => new Date(b.modified) - new Date(a.modified)).forEach(project => {
                    const item = document.createElement('div');
                    item.className = 'project-item';
                    if (project.id === state.currentProject) {
                        item.classList.add('selected');
                    }
                    item.dataset.id = project.id;
                    item.innerHTML = `
                        <div>
                            <div>${project.name}</div>
                            <div class="project-date">Modified: ${new Date(project.modified).toLocaleString()}</div>
                        </div>
                        <div class="project-actions-cell">
                            <button class="project-action-btn delete-project-btn" title="Delete Project">&#x1F5D1;</button>
                        </div>
                    `;
                    item.addEventListener('click', (e) => {
                        if (e.target.classList.contains('delete-project-btn')) {
                             e.stopPropagation();
                             deleteProject(project.id);
                             return;
                        }
                        document.querySelectorAll('.project-item').forEach(i => i.classList.remove('selected'));
                        item.classList.add('selected');
                        if (e.detail === 2) { // Double click
                            loadProject(project.id);
                            closeModal();
                        }
                    });
                    list.appendChild(item);
                });
            }
            modal.classList.add('active');
        }

        function showSettingsModal() {
             document.getElementById('settingsTheme').value = state.settings.theme;
             document.getElementById('settingsGridSpacing').value = state.settings.gridSpacing;
             document.getElementById('settingsSnapToGrid').checked = state.settings.snapToGrid;
             document.getElementById('settingsAutosaveInterval').value = state.settings.autosaveInterval;
             document.getElementById('settingsModal').classList.add('active');
        }

        function closeModal() {
            document.querySelectorAll('.modal').forEach(modal => {
                modal.classList.remove('active');
            });
        }

        function showQuickActions() {
             // Placeholder for future quick actions
            showSettingsModal();
        }


        // --- Initialization and Event Listeners ---
        function setupEventListeners() {
            // Tool buttons
            document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                btn.addEventListener('click', () => selectTool(btn.dataset.tool));
            });

            // Canvas interactions
            const canvasContainer = document.getElementById('canvasContainer');
            canvasContainer.addEventListener('mousedown', handleCanvasMouseDown);
            canvasContainer.addEventListener('mousemove', handleCanvasMouseMove);
            canvasContainer.addEventListener('mouseup', handleCanvasMouseUp);
            canvasContainer.addEventListener('mouseleave', handleCanvasMouseUp);
            canvasContainer.addEventListener('wheel', handleCanvasWheel);
            canvasContainer.addEventListener('mousedown', handleCanvasMouseDownForPanning); // For middle mouse panning

            // Global key events
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);

            // Zoom controls
            document.getElementById('zoomIn').addEventListener('click', () => zoom(1.2, window.innerWidth/2, window.innerHeight/2));
            document.getElementById('zoomOut').addEventListener('click', () => zoom(0.8, window.innerWidth/2, window.innerHeight/2));
            document.getElementById('zoomReset').addEventListener('click', resetZoom);
            document.getElementById('zoomFit').addEventListener('click', fitToScreen);
            document.getElementById('zoomLevelInput').addEventListener('click', () => {
                const input = document.getElementById('zoomLevelInput');
                input.select();
            });
            document.getElementById('zoomLevelInput').addEventListener('change', (e) => {
                let value = parseInt(e.target.value);
                if (isNaN(value)) value = 100;
                value = Math.max(10, Math.min(500, value));
                const newZoom = value / 100;
                const oldZoom = state.canvas.zoom;
                state.canvas.zoom = newZoom;

                // Adjust pan to keep center
                const container = document.getElementById('canvasContainer');
                const centerX = (container.clientWidth / 2 - state.canvas.panX) / oldZoom;
                const centerY = (container.clientHeight / 2 - state.canvas.panY) / oldZoom;
                state.canvas.panX = container.clientWidth / 2 - centerX * newZoom;
                state.canvas.panY = container.clientHeight / 2 - centerY * newZoom;

                updateCanvasTransform();
                updateZoomDisplay();
                saveToHistory("Zoom");
            });

            // Project actions
            document.getElementById('newProjectBtn').addEventListener('click', showNewProjectModal);
            document.getElementById('openProjectBtn').addEventListener('click', showProjectModal);
            document.getElementById('saveProjectBtn').addEventListener('click', saveCurrentProject);
            document.getElementById('exportBtn').addEventListener('click', exportProject);
            document.getElementById('importBtn').addEventListener('click', importProject);
            document.getElementById('themeToggleBtn').addEventListener('click', showSettingsModal);

            // Grid toggle
            document.getElementById('gridToggle').addEventListener('click', toggleGrid);

            // Undo/Redo
            document.getElementById('undoBtn').addEventListener('click', undo);
            document.getElementById('redoBtn').addEventListener('click', redo);

            // Properties panel listeners
            // Brush
            document.getElementById('brushSize').addEventListener('input', (e) => {
                state.brushSettings.size = parseInt(e.target.value);
                document.getElementById('brushSizeValue').textContent = e.target.value;
            });
            document.getElementById('brushOpacity').addEventListener('input', (e) => {
                state.brushSettings.opacity = parseInt(e.target.value) / 100;
                document.getElementById('brushOpacityValue').textContent = e.target.value;
            });
            document.querySelectorAll('.color-swatch').forEach(swatch => {
                swatch.addEventListener('click', () => {
                    document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
                    swatch.classList.add('active');
                    state.brushSettings.color = swatch.dataset.color;
                });
            });

            // Text
            document.getElementById('fontFamily').addEventListener('change', (e) => {
                state.textSettings.fontFamily = e.target.value;
                state.canvas.selectedElements.filter(el => el.type === 'text').forEach(el => {
                    el.element.style.fontFamily = e.target.value;
                });
                if (state.canvas.selectedElements.some(el => el.type === 'text')) saveToHistory("Change Text Font");
            });
            document.getElementById('fontSize').addEventListener('input', (e) => {
                const size = parseInt(e.target.value);
                state.textSettings.fontSize = size;
                state.canvas.selectedElements.filter(el => el.type === 'text').forEach(el => {
                    el.element.style.fontSize = size + 'px';
                });
                if (state.canvas.selectedElements.some(el => el.type === 'text')) saveToHistory("Change Text Size");
            });
            document.getElementById('textColor').addEventListener('input', (e) => {
                state.textSettings.color = e.target.value;
                state.canvas.selectedElements.filter(el => el.type === 'text').forEach(el => {
                    el.element.style.color = e.target.value;
                });
                if (state.canvas.selectedElements.some(el => el.type === 'text')) saveToHistory("Change Text Color");
            });
            document.getElementById('boldBtn').addEventListener('click', () => {
                state.textSettings.bold = !state.textSettings.bold;
                state.canvas.selectedElements.filter(el => el.type === 'text').forEach(el => {
                    el.element.style.fontWeight = state.textSettings.bold ? 'bold' : 'normal';
                });
                if (state.canvas.selectedElements.some(el => el.type === 'text')) saveToHistory("Toggle Text Bold");
            });
            document.getElementById('italicBtn').addEventListener('click', () => {
                state.textSettings.italic = !state.textSettings.italic;
                state.canvas.selectedElements.filter(el => el.type === 'text').forEach(el => {
                    el.element.style.fontStyle = state.textSettings.italic ? 'italic' : 'normal';
                });
                if (state.canvas.selectedElements.some(el => el.type === 'text')) saveToHistory("Toggle Text Italic");
            });
            document.getElementById('underlineBtn').addEventListener('click', () => {
                state.textSettings.underline = !state.textSettings.underline;
                state.canvas.selectedElements.filter(el => el.type === 'text').forEach(el => {
                    el.element.style.textDecoration = state.textSettings.underline ? 'underline' : 'none';
                });
                if (state.canvas.selectedElements.some(el => el.type === 'text')) saveToHistory("Toggle Text Underline");
            });
             document.getElementById('alignLeftBtn').addEventListener('click', () => {
                state.textSettings.align = 'left';
                state.canvas.selectedElements.filter(el => el.type === 'text').forEach(el => {
                    el.element.style.textAlign = 'left';
                });
                if (state.canvas.selectedElements.some(el => el.type === 'text')) saveToHistory("Align Text Left");
            });
            document.getElementById('alignCenterBtn').addEventListener('click', () => {
                state.textSettings.align = 'center';
                state.canvas.selectedElements.filter(el => el.type === 'text').forEach(el => {
                    el.element.style.textAlign = 'center';
                });
                if (state.canvas.selectedElements.some(el => el.type === 'text')) saveToHistory("Align Text Center");
            });
            document.getElementById('alignRightBtn').addEventListener('click', () => {
                state.textSettings.align = 'right';
                state.canvas.selectedElements.filter(el => el.type === 'text').forEach(el => {
                    el.element.style.textAlign = 'right';
                });
                if (state.canvas.selectedElements.some(el => el.type === 'text')) saveToHistory("Align Text Right");
            });

            // Shape
            document.getElementById('shapeType').addEventListener('change', (e) => {
                state.shapeSettings.type = e.target.value;
            });
            document.getElementById('shapeFillColor').addEventListener('input', (e) => {
                state.shapeSettings.fillColor = e.target.value;
                state.canvas.selectedElements.filter(el => el.type === 'shape').forEach(el => {
                    const shape = el.element.querySelector('.flowchart-shape');
                    if (shape) shape.setAttribute('fill', e.target.value);
                    el.fillColor = e.target.value; // Update state
                });
                if (state.canvas.selectedElements.some(el => el.type === 'shape')) saveToHistory("Change Shape Fill");
            });
            document.getElementById('shapeStrokeColor').addEventListener('input', (e) => {
                state.shapeSettings.strokeColor = e.target.value;
                state.canvas.selectedElements.filter(el => el.type === 'shape').forEach(el => {
                    const shape = el.element.querySelector('.flowchart-shape');
                    if (shape) shape.setAttribute('stroke', e.target.value);
                    el.strokeColor = e.target.value; // Update state
                });
                if (state.canvas.selectedElements.some(el => el.type === 'shape')) saveToHistory("Change Shape Stroke");
            });
            document.getElementById('shapeStrokeWidth').addEventListener('input', (e) => {
                const width = parseInt(e.target.value);
                state.shapeSettings.strokeWidth = width;
                state.canvas.selectedElements.filter(el => el.type === 'shape').forEach(el => {
                    const shape = el.element.querySelector('.flowchart-shape');
                    if (shape) shape.setAttribute('stroke-width', width);
                    el.strokeWidth = width; // Update state
                });
                if (state.canvas.selectedElements.some(el => el.type === 'shape')) saveToHistory("Change Shape Stroke Width");
            });
            document.getElementById('shapeWidth').addEventListener('input', (e) => {
                const width = parseInt(e.target.value);
                state.shapeSettings.width = width;
                // This changes the *default* for new shapes, not existing ones.
                // Changing existing shapes is done via resize handles or direct input in element properties.
            });
             document.getElementById('shapeHeight').addEventListener('input', (e) => {
                const height = parseInt(e.target.value);
                state.shapeSettings.height = height;
                // This changes the *default* for new shapes, not existing ones.
            });

            // Connector
            document.getElementById('connectorStrokeColor').addEventListener('input', (e) => {
                state.connectorSettings.strokeColor = e.target.value;
                state.canvas.selectedElements.filter(el => el.type === 'connector').forEach(el => {
                    const path = el.element.querySelector('.connector-path');
                    if (path) path.setAttribute('stroke', e.target.value);
                    el.strokeColor = e.target.value; // Update state
                });
                if (state.canvas.selectedElements.some(el => el.type === 'connector')) saveToHistory("Change Connector Color");
            });
            document.getElementById('connectorStrokeWidth').addEventListener('input', (e) => {
                 const width = parseInt(e.target.value);
                 state.connectorSettings.strokeWidth = width;
                 state.canvas.selectedElements.filter(el => el.type === 'connector').forEach(el => {
                    const path = el.element.querySelector('.connector-path');
                    if (path) path.setAttribute('stroke-width', width);
                    el.strokeWidth = width; // Update state
                });
                if (state.canvas.selectedElements.some(el => el.type === 'connector')) saveToHistory("Change Connector Width");
            });
            document.getElementById('connectorArrowheads').addEventListener('change', (e) => {
                state.connectorSettings.arrowheads = e.target.value;
                 state.canvas.selectedElements.filter(el => el.type === 'connector').forEach(el => {
                    const path = el.element.querySelector('.connector-path');
                    if (path) {
                        path.removeAttribute('marker-start');
                        path.removeAttribute('marker-end');
                        if (e.target.value === 'end' || e.target.value === 'both') {
                            path.setAttribute('marker-end', 'url(#arrowhead)');
                        }
                        if (e.target.value === 'start' || e.target.value === 'both') {
                            path.setAttribute('marker-start', 'url(#arrowhead)');
                        }
                    }
                    el.arrowheads = e.target.value; // Update state
                });
                if (state.canvas.selectedElements.some(el => el.type === 'connector')) saveToHistory("Change Connector Arrows");
            });

            // Code
            document.getElementById('codeLanguage').addEventListener('change', (e) => {
                state.codeSettings.language = e.target.value;
                state.canvas.selectedElements.filter(el => el.type === 'code').forEach(el => {
                    const codeEl = el.element.querySelector('code');
                    const oldClass = [...codeEl.classList].find(cls => cls.startsWith('language-'));
                    if (oldClass) codeEl.classList.remove(oldClass);
                    const newClass = `language-${e.target.value}`;
                    codeEl.classList.add(newClass);
                    el.language = e.target.value; // Update state
                    if (typeof Prism !== 'undefined') {
                        Prism.highlightElement(codeEl);
                    }
                });
                if (state.canvas.selectedElements.some(el => el.type === 'code')) saveToHistory("Change Code Language");
            });
            document.getElementById('copyCodeBtn').addEventListener('click', copyCodeToClipboard);

            // Element Actions (apply to all selected)
            document.getElementById('deleteElementBtn').addEventListener('click', deleteSelectedElements);
            document.getElementById('bringToFrontBtn').addEventListener('click', () => changeElementOrder('front'));
            document.getElementById('sendToBackBtn').addEventListener('click', () => changeElementOrder('back'));
            document.getElementById('duplicateElementBtn').addEventListener('click', duplicateSelectedElements);
            document.getElementById('lockElementBtn').addEventListener('click', lockSelectedElements);
            document.getElementById('groupElementsBtn').addEventListener('click', groupSelectedElements);

            // Element Property Inputs (apply to all selected)
            document.getElementById('elementX').addEventListener('change', (e) => {
                const val = parseInt(e.target.value);
                if (isNaN(val)) return;
                state.canvas.selectedElements.forEach(el => {
                    if (!el.isLocked) {
                        el.x = snapToGrid(val);
                        el.element.style.left = el.x + 'px';
                        if (el.type === 'shape') updateConnectedConnectors(el);
                    }
                });
                saveToHistory("Move Element");
            });
            document.getElementById('elementY').addEventListener('change', (e) => {
                const val = parseInt(e.target.value);
                if (isNaN(val)) return;
                state.canvas.selectedElements.forEach(el => {
                    if (!el.isLocked) {
                        el.y = snapToGrid(val);
                        el.element.style.top = el.y + 'px';
                        if (el.type === 'shape') updateConnectedConnectors(el);
                    }
                });
                saveToHistory("Move Element");
            });
            document.getElementById('elementWidth').addEventListener('change', (e) => {
                const val = parseInt(e.target.value);
                if (isNaN(val) || val < 20) return;
                state.canvas.selectedElements.forEach(el => {
                     if (!el.isLocked && (el.type === 'text' || el.type === 'code' || el.type === 'shape')) {
                        el.width = snapToGrid(val);
                        el.element.style.width = el.width + 'px';
                        if (el.type === 'text') {
                            el.element.style.height = 'auto';
                            el.element.style.height = el.element.scrollHeight + 'px';
                            el.height = el.element.scrollHeight;
                        }
                        if (el.type === 'shape') {
                            updateShapeSVG(el);
                            updateConnectedConnectors(el); // Important for connectors
                        }
                    }
                });
                saveToHistory("Resize Element");
            });
            document.getElementById('elementHeight').addEventListener('change', (e) => {
                const val = parseInt(e.target.value);
                if (isNaN(val) || val < 20) return;
                state.canvas.selectedElements.forEach(el => {
                     if (!el.isLocked && (el.type === 'text' || el.type === 'code')) {
                        el.height = snapToGrid(val);
                        el.element.style.height = el.height + 'px';
                    }
                });
                saveToHistory("Resize Element");
            });

            // FAB menu
            document.getElementById('fabMenu').addEventListener('click', showQuickActions);

            // Modal actions
            document.getElementById('createProjectBtn').addEventListener('click', () => {
                const name = document.getElementById('newProjectName').value.trim();
                if (name) {
                    createNewProject(name);
                    closeModal();
                }
            });
            document.getElementById('loadProjectBtn').addEventListener('click', () => {
                const selected = document.querySelector('.project-item.selected');
                if (selected) {
                    loadProject(selected.dataset.id);
                    closeModal();
                }
            });
            document.getElementById('cancelProjectBtn').addEventListener('click', closeModal);
            document.getElementById('cancelNewProjectBtn').addEventListener('click', closeModal);

            // Settings Modal
            document.getElementById('saveSettingsBtn').addEventListener('click', () => {
                 const newTheme = document.getElementById('settingsTheme').value;
                 if (newTheme !== state.settings.theme) {
                    applyTheme(newTheme);
                 }
                 state.settings.gridSpacing = parseInt(document.getElementById('settingsGridSpacing').value) || 20;
                 state.settings.snapToGrid = document.getElementById('settingsSnapToGrid').checked;
                 state.settings.autosaveInterval = parseInt(document.getElementById('settingsAutosaveInterval').value) || 30;

                 localStorage.setItem('codecanvas_theme', state.settings.theme);
                 localStorage.setItem('codecanvas_grid_spacing', state.settings.gridSpacing);
                 localStorage.setItem('codecanvas_snap_to_grid', state.settings.snapToGrid);
                 localStorage.setItem('codecanvas_autosave_interval', state.settings.autosaveInterval);

                 // Update grid if spacing changed
                 const grid = document.querySelector('.canvas-grid');
                 if (grid) {
                    grid.style.backgroundSize = `${state.settings.gridSpacing}px ${state.settings.gridSpacing}px`;
                 }

                 // Update autosave interval
                 clearInterval(state._autosaveIntervalId);
                 state._autosaveIntervalId = setInterval(saveCurrentProject, state.settings.autosaveInterval * 1000);

                 closeModal();
                 saveToHistory("Change Settings");
                 showNotification('Settings saved.');
            });
            document.getElementById('cancelSettingsBtn').addEventListener('click', closeModal);

            // Modal close buttons (X) and backdrop
            document.querySelectorAll('.modal-close').forEach(btn => {
                btn.addEventListener('click', closeModal);
            });
            document.querySelectorAll('.modal').forEach(modal => {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) closeModal();
                });
            });

            // Properties Panel Toggle
            document.getElementById('togglePropertiesPanel').addEventListener('click', () => {
                document.getElementById('propertiesPanel').classList.toggle('hidden');
            });
        }


        function initializeApp() {
            const canvasContainer = document.getElementById('canvasContainer');
            const canvas = document.getElementById('canvas');

            // Apply initial theme
            applyTheme(state.settings.theme);

            // Center the canvas initially
            resetZoom(); // This will center it

            // Set grid size
            const grid = document.querySelector('.canvas-grid');
            if (grid) {
                grid.style.backgroundSize = `${state.settings.gridSpacing}px ${state.settings.gridSpacing}px`;
            }

             // Focus the app container for key events
             document.getElementById('appContainer').focus();

             // Start autosave
             state._autosaveIntervalId = setInterval(saveCurrentProject, state.settings.autosaveInterval * 1000);

             showNotification('Welcome to CodeCanvas!');
        }

        // --- Main Execution ---
        document.addEventListener('DOMContentLoaded', () => {
            initializeApp();
            setupEventListeners();
            loadProjects();
        });
    </script>
</body>
</html>
                    
