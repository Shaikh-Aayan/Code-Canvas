
                            <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CodeCanvas - Ultimate Ideation Studio</title>
    <!-- Embedded Prism.js for Syntax Highlighting -->
    <!-- Includes core + languages + themes -->
    <style>
        /* PrismJS Themes - Embedded */
        /* PrismJS 1.29.0 - Dark Theme */
        pre[class*="language-"] {
            color: #f8f8f2;
            background: #272822;
        }
        .token.comment, .token.prolog, .token.doctype, .token.cdata {
            color: #75715e;
        }
        .token.punctuation {
            color: #f8f8f2;
        }
        .token.property, .token.tag, .token.constant, .token.symbol, .token.deleted {
            color: #f92672;
        }
        .token.boolean, .token.number {
            color: #ae81ff;
        }
        .token.selector, .token.attr-name, .token.string, .token.char, .token.builtin, .token.inserted {
            color: #a6e22e;
        }
        .token.operator, .token.entity, .token.url, .language-css .token.string, .style .token.string, .token.variable {
            color: #f8f8f2;
        }
        .token.atrule, .token.attr-value, .token.function, .token.class-name {
            color: #e6db74;
        }
        .token.keyword {
            color: #66d9ef;
        }
        .token.regex, .token.important {
            color: #fd971f;
        }
        .token.important, .token.bold {
            font-weight: bold;
        }
        .token.italic {
            font-style: italic;
        }
        .token.entity {
            cursor: help;
        }

        /* PrismJS 1.29.0 - Light Theme */
        pre[class*="language-"].light-theme {
            color: #24292e;
            background: #ffffff;
        }
        pre[class*="language-"].light-theme .token.comment,
        pre[class*="language-"].light-theme .token.prolog,
        pre[class*="language-"].light-theme .token.doctype,
        pre[class*="language-"].light-theme .token.cdata {
            color: #6a737d;
        }
        pre[class*="language-"].light-theme .token.punctuation {
            color: #24292e;
        }
        pre[class*="language-"].light-theme .token.property,
        pre[class*="language-"].light-theme .token.tag,
        pre[class*="language-"].light-theme .token.boolean,
        pre[class*="language-"].light-theme .token.number,
        pre[class*="language-"].light-theme .token.constant,
        pre[class*="language-"].light-theme .token.symbol,
        pre[class*="language-"].light-theme .token.deleted {
            color: #d73a49;
        }
        pre[class*="language-"].light-theme .token.selector,
        pre[class*="language-"].light-theme .token.attr-name,
        pre[class*="language-"].light-theme .token.string,
        pre[class*="language-"].light-theme .token.char,
        pre[class*="language-"].light-theme .token.builtin,
        pre[class*="language-"].light-theme .token.inserted {
            color: #032f62;
        }
        pre[class*="language-"].light-theme .token.operator,
        pre[class*="language-"].light-theme .token.entity,
        pre[class*="language-"].light-theme .token.url,
        pre[class*="language-"].light-theme .language-css .token.string,
        pre[class*="language-"].light-theme .style .token.string,
        pre[class*="language-"].light-theme .token.variable {
            color: #24292e;
        }
        pre[class*="language-"].light-theme .token.atrule,
        pre[class*="language-"].light-theme .token.attr-value,
        pre[class*="language-"].light-theme .token.function,
        pre[class*="language-"].light-theme .token.class-name {
            color: #6f42c1;
        }
        pre[class*="language-"].light-theme .token.keyword {
            color: #d73a49;
        }
        pre[class*="language-"].light-theme .token.regex,
        pre[class*="language-"].light-theme .token.important {
            color: #e36209;
        }

        /* PrismJS 1.29.0 - Monokai Theme */
        pre[class*="language-"].monokai-theme {
            color: #f8f8f2;
            background: #272822;
        }
        pre[class*="language-"].monokai-theme .token.comment,
        pre[class*="language-"].monokai-theme .token.prolog,
        pre[class*="language-"].monokai-theme .token.doctype,
        pre[class*="language-"].monokai-theme .token.cdata {
            color: #75715e;
        }
        pre[class*="language-"].monokai-theme .token.punctuation {
            color: #f8f8f2;
        }
        pre[class*="language-"].monokai-theme .token.property,
        pre[class*="language-"].monokai-theme .token.tag,
        pre[class*="language-"].monokai-theme .token.constant,
        pre[class*="language-"].monokai-theme .token.symbol,
        pre[class*="language-"].monokai-theme .token.deleted {
            color: #f92672;
        }
        pre[class*="language-"].monokai-theme .token.boolean,
        pre[class*="language-"].monokai-theme .token.number {
            color: #ae81ff;
        }
        pre[class*="language-"].monokai-theme .token.selector,
        pre[class*="language-"].monokai-theme .token.attr-name,
        pre[class*="language-"].monokai-theme .token.string,
        pre[class*="language-"].monokai-theme .token.char,
        pre[class*="language-"].monokai-theme .token.builtin,
        pre[class*="language-"].monokai-theme .token.inserted {
            color: #a6e22e;
        }
        pre[class*="language-"].monokai-theme .token.operator,
        pre[class*="language-"].monokai-theme .token.entity,
        pre[class*="language-"].monokai-theme .token.url,
        pre[class*="language-"].monokai-theme .language-css .token.string,
        pre[class*="language-"].monokai-theme .style .token.string,
        pre[class*="language-"].monokai-theme .token.variable {
            color: #f8f8f2;
        }
        pre[class*="language-"].monokai-theme .token.atrule,
        pre[class*="language-"].monokai-theme .token.attr-value,
        pre[class*="language-"].monokai-theme .token.function,
        pre[class*="language-"].monokai-theme .token.class-name {
            color: #e6db74;
        }
        pre[class*="language-"].monokai-theme .token.keyword {
            color: #66d9ef;
        }
        pre[class*="language-"].monokai-theme .token.regex,
        pre[class*="language-"].monokai-theme .token.important {
            color: #fd971f;
        }
        pre[class*="language-"].monokai-theme .token.important,
        pre[class*="language-"].monokai-theme .token.bold {
            font-weight: bold;
        }
        pre[class*="language-"].monokai-theme .token.italic {
            font-style: italic;
        }
        pre[class*="language-"].monokai-theme .token.entity {
            cursor: help;
        }

        /* PrismJS Core Styles */
        code[class*="language-"],
        pre[class*="language-"] {
            color: #f8f8f2;
            background: none;
            text-shadow: 0 1px rgba(0, 0, 0, 0.3);
            font-family: "Fira Code", "Consolas", "Monaco", "Andale Mono", "Ubuntu Mono", monospace;
            font-size: 1em;
            text-align: left;
            white-space: pre;
            word-spacing: normal;
            word-break: normal;
            word-wrap: normal;
            line-height: 1.5;

            -moz-tab-size: 4;
            -o-tab-size: 4;
            tab-size: 4;

            -webkit-hyphens: none;
            -moz-hyphens: none;
            -ms-hyphens: none;
            hyphens: none;
        }

        pre[class*="language-"] {
            padding: 1em;
            margin: .5em 0;
            overflow: auto;
            border-radius: 0.3em;
        }

        :not(pre) > code[class*="language-"],
        pre[class*="language-"] {
            background: #272822;
        }

        :not(pre) > code[class*="language-"] {
            padding: .1em;
            border-radius: .3em;
            white-space: normal;
        }

        /* --- End of PrismJS Themes --- */

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --bg-hover: #30363d;
            --border-primary: #30363d;
            --border-secondary: #21262d;
            --text-primary: #c9d1d9;
            --text-secondary: #8b949e;
            --text-tertiary: #58a6ff;
            --accent-primary: #58a6ff;
            --accent-secondary: #1f6feb;
            --accent-success: #3fb950;
            --accent-warning: #d29922;
            --accent-danger: #f85149;
            --shadow-sm: 0 1px 0 rgba(27,31,35,0.04);
            --shadow-md: 0 3px 6px rgba(0,0,0,0.3);
            --shadow-lg: 0 8px 24px rgba(0,0,0,0.4);
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans", Helvetica, Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
            user-select: none;
        }
        .app-container {
            display: flex;
            height: 100vh;
            position: relative;
        }
        /* Toolbar */
        .toolbar {
            width: 60px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-primary);
            display: flex;
            flex-direction: column;
            padding: 10px 0;
            z-index: 100;
            box-shadow: var(--shadow-md);
        }
        .tool-btn {
            width: 44px;
            height: 44px;
            margin: 4px auto;
            background: var(--bg-tertiary);
            border: 2px solid transparent;
            border-radius: 8px;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            position: relative;
        }
        .tool-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }
        .tool-btn.active {
            background: var(--accent-primary);
            color: white;
            border-color: var(--accent-secondary);
            box-shadow: 0 0 12px rgba(88, 166, 255, 0.4);
        }
        .tool-btn svg {
            width: 20px;
            height: 20px;
        }
        .tooltip {
            position: absolute;
            left: 100%;
            margin-left: 10px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 1000;
            box-shadow: var(--shadow-lg);
        }
        .tool-btn:hover .tooltip {
            opacity: 1;
        }
        .toolbar-divider {
            height: 1px;
            background: var(--border-primary);
            margin: 8px 10px;
        }
        /* Properties Panel */
        .properties-panel {
            width: 280px;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-primary);
            padding: 20px;
            overflow-y: auto;
            z-index: 100;
            transition: transform 0.3s ease;
            box-shadow: var(--shadow-md);
        }
        .properties-panel.hidden {
            transform: translateX(100%);
        }
        .property-group {
            margin-bottom: 20px;
        }
        .property-label {
            display: block;
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .property-input {
            width: 100%;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 14px;
            transition: all 0.2s ease;
        }
        .property-input:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(88, 166, 255, 0.1);
        }
        .property-input[type="range"] {
            padding: 4px 0;
        }
        .color-picker-wrapper {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .color-swatch {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s ease;
        }
        .color-swatch:hover {
            transform: scale(1.1);
            border-color: var(--text-primary);
        }
        .color-swatch.active {
            border-color: var(--accent-primary);
            box-shadow: 0 0 8px rgba(88, 166, 255, 0.4);
        }
        /* Canvas Area */
        .canvas-container {
            flex: 1;
            position: relative;
            background: var(--bg-primary);
            overflow: hidden;
        }
        .canvas {
            position: absolute;
            width: 5000px;
            height: 5000px;
            background-image: 
                linear-gradient(var(--border-secondary) 1px, transparent 1px),
                linear-gradient(90deg, var(--border-secondary) 1px, transparent 1px);
            background-size: 20px 20px;
            transform-origin: 0 0; /* Changed for better zoom centering */
        }
        .canvas.no-grid {
            background-image: none;
        }
        /* Top Bar */
        .top-bar {
            position: absolute;
            top: 0;
            left: 60px;
            right: 280px;
            height: 50px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-primary);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 99;
            box-shadow: var(--shadow-sm);
        }
        .project-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .project-name {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
        }
        .project-actions {
            display: flex;
            gap: 10px;
        }
        .btn {
            padding: 6px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .btn:hover {
            background: var(--bg-hover);
            transform: translateY(-1px);
            box-shadow: var(--shadow-sm);
        }
        .btn-primary {
            background: var(--accent-primary);
            border-color: var(--accent-secondary);
            color: white;
        }
        .btn-primary:hover {
            background: var(--accent-secondary);
        }
        .btn-danger {
            background: var(--accent-danger);
            border-color: #da3633;
            color: white;
        }
        .btn-danger:hover {
            background: #da3633;
        }
        /* Zoom Controls */
        .zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 300px;
            display: flex;
            gap: 8px;
            background: var(--bg-secondary);
            padding: 8px;
            border-radius: 8px;
            box-shadow: var(--shadow-lg);
        }
        .zoom-btn {
            width: 32px;
            height: 32px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 6px;
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        .zoom-btn:hover {
            background: var(--bg-hover);
        }
        .zoom-level {
            min-width: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: var(--text-secondary);
        }
        /* Canvas Elements */
        .canvas-element {
            position: absolute;
            cursor: move;
            user-select: text; /* Allow text selection in text/code elements */
        }
        .canvas-element.selected {
            outline: 2px solid var(--accent-primary);
            outline-offset: 2px;
            z-index: 10; /* Ensure selected element is on top during manipulation */
        }
        .text-element {
            padding: 10px;
            background: transparent;
            border: none;
            color: var(--text-primary);
            font-family: inherit;
            resize: none;
            outline: none;
            min-width: 100px;
            min-height: 30px;
            overflow: hidden;
        }
        .code-element {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 15px;
            font-family: 'Fira Code', 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            white-space: pre;
            overflow: auto;
            min-width: 200px;
            min-height: 100px;
            outline: none;
        }
        .shape-element {
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: all; /* Ensure shape SVG handles events */
        }
        .shape-element svg {
             pointer-events: all;
        }
        /* Connector Elements */
        .connector-element {
            pointer-events: all; /* Ensure connector SVG handles events */
            cursor: pointer;
        }
        .connector-element.selected {
            filter: drop-shadow(0 0 2px var(--accent-primary));
        }
        .connector-path {
            fill: none;
            stroke: var(--text-primary);
            stroke-width: 2;
            marker-end: url(#arrowhead);
        }
        .connector-label {
            font-family: sans-serif;
            font-size: 12px;
            fill: var(--text-primary);
            pointer-events: all; /* Allow interaction with label */
            cursor: text;
        }
        .connector-point {
            fill: rgba(88, 166, 255, 0.5);
            stroke: var(--accent-primary);
            stroke-width: 1;
            cursor: crosshair;
            pointer-events: all;
        }
        .connector-point:hover {
            fill: var(--accent-primary);
            r: 6; /* Slightly larger on hover */
        }
        /* Flowchart Shapes */
        .flowchart-shape {
            cursor: pointer;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .modal.active {
            display: flex;
        }
        .modal-content {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: var(--shadow-lg);
        }
        .modal-header {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 20px;
            color: var(--text-primary);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 20px;
        }
        .modal-close:hover {
            color: var(--text-primary);
        }
        .modal-body {
            margin-bottom: 20px;
        }
        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        .project-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            background: var(--bg-tertiary);
        }
        .project-item {
            padding: 12px 15px;
            border-bottom: 1px solid var(--border-primary);
            cursor: pointer;
            transition: background 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .project-item:hover {
            background: var(--bg-hover);
        }
        .project-item.selected {
            background: var(--bg-hover);
        }
        .project-item:last-child {
            border-bottom: none;
        }
        .project-date {
            font-size: 11px;
            color: var(--text-secondary);
        }
        .project-actions-cell {
            display: flex;
            gap: 5px;
        }
        .project-action-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 2px;
        }
        .project-action-btn:hover {
            color: var(--accent-danger);
        }
        /* Floating Action Button */
        .fab {
            position: fixed;
            bottom: 20px;
            left: 80px;
            width: 56px;
            height: 56px;
            background: var(--accent-primary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            box-shadow: var(--shadow-lg);
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 100;
        }
        .fab:hover {
            transform: scale(1.1) rotate(90deg);
            background: var(--accent-secondary);
            box-shadow: 0 0 20px rgba(88, 166, 255, 0.6);
        }
        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in {
            animation: fadeIn 0.3s ease;
        }
        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
        }
        ::-webkit-scrollbar-thumb {
            background: var(--border-primary);
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Toolbar -->
        <div class="toolbar">
            <button class="tool-btn active" data-tool="select">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/>
                </svg>
                <span class="tooltip">Select Tool (V)</span>
            </button>
            <button class="tool-btn" data-tool="brush">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 2L2 7v10c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V7l-10-5z"/>
                </svg>
                <span class="tooltip">Brush Tool (B)</span>
            </button>
            <button class="tool-btn" data-tool="eraser">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 21H9l-7-7a2 2 0 010-2.83l10-10a2 2 0 012.83 0l7 7a2 2 0 010 2.83L13 21"/>
                </svg>
                <span class="tooltip">Eraser Tool (E)</span>
            </button>
            <button class="tool-btn" data-tool="text">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M13 4h-2v16h2M6 20h12M6 4h12"/>
                </svg>
                <span class="tooltip">Text Tool (T)</span>
            </button>
            <button class="tool-btn" data-tool="shape">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="3" width="18" height="18" rx="2"/>
                </svg>
                <span class="tooltip">Shape Tool (S)</span>
            </button>
            <button class="tool-btn" data-tool="connector">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M9 11L3 17l6 6 6-6-6-6zM21 3l-6 6 6 6"/>
                </svg>
                <span class="tooltip">Connector Tool (C)</span>
            </button>
            <button class="tool-btn" data-tool="code">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="16 18 22 12 16 6"/>
                    <polyline points="8 6 2 12 8 18"/>
                </svg>
                <span class="tooltip">Code Snippet</span>
            </button>
            <div class="toolbar-divider"></div>
            <button class="tool-btn" id="undoBtn">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M3 7v6h6"/>
                    <path d="M21 17a9 9 0 00-9-9 9 9 0 00-6 2.3L3 13"/>
                </svg>
                <span class="tooltip">Undo (Ctrl+Z)</span>
            </button>
            <button class="tool-btn" id="redoBtn">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 7v6h-6"/>
                    <path d="M3 17a9 9 0 019-9 9 9 0 016 2.3L21 13"/>
                </svg>
                <span class="tooltip">Redo (Ctrl+Y)</span>
            </button>
            <button class="tool-btn" id="gridToggle">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="3" width="6" height="6"/>
                    <rect x="15" y="3" width="6" height="6"/>
                    <rect x="3" y="15" width="6" height="6"/>
                    <rect x="15" y="15" width="6" height="6"/>
                </svg>
                <span class="tooltip">Toggle Grid</span>
            </button>
        </div>
        <!-- Canvas Container -->
        <div class="canvas-container">
            <!-- Top Bar -->
            <div class="top-bar">
                <div class="project-info">
                    <span class="project-name" id="projectName">Untitled Project</span>
                </div>
                <div class="project-actions">
                    <button class="btn" id="newProjectBtn">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="12" y1="5" x2="12" y2="19"/>
                            <line x1="5" y1="12" x2="19" y2="12"/>
                        </svg>
                        New
                    </button>
                    <button class="btn" id="openProjectBtn">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2z"/>
                        </svg>
                        Open
                    </button>
                    <button class="btn" id="saveProjectBtn">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M19 21H5a2 2 0 01-2-2V5a2 2 0 012-2h11l5 5v11a2 2 0 01-2 2z"/>
                            <polyline points="17 21 17 13 7 13 7 21"/>
                            <polyline points="7 3 7 8 15 8"/>
                        </svg>
                        Save
                    </button>
                    <button class="btn btn-primary" id="exportBtn">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/>
                            <polyline points="7 10 12 15 17 10"/>
                            <line x1="12" y1="15" x2="12" y2="3"/>
                        </svg>
                        Export
                    </button>
                    <button class="btn" id="importBtn">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/>
                            <polyline points="17 8 12 3 7 8"/>
                            <line x1="12" y1="3" x2="12" y2="15"/>
                        </svg>
                        Import
                    </button>
                </div>
            </div>
            <!-- Canvas -->
            <div class="canvas" id="canvas">
                <!-- SVG Definitions for Markers -->
                <svg style="position: absolute; width: 0; height: 0;">
                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                        refX="10" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="var(--text-primary)"/>
                        </marker>
                    </defs>
                </svg>
            </div>
            <!-- Zoom Controls -->
            <div class="zoom-controls">
                <button class="zoom-btn" id="zoomOut">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="5" y1="12" x2="19" y2="12"/>
                    </svg>
                </button>
                <div class="zoom-level" id="zoomLevel">100%</div>
                <button class="zoom-btn" id="zoomIn">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="12" y1="5" x2="12" y2="19"/>
                        <line x1="5" y1="12" x2="19" y2="12"/>
                    </svg>
                </button>
                <button class="zoom-btn" id="zoomReset">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="11" cy="11" r="8"/>
                        <path d="M21 21l-4.35-4.35"/>
                    </svg>
                </button>
            </div>
        </div>
        <!-- Properties Panel -->
        <div class="properties-panel" id="propertiesPanel">
            <h3 style="margin-bottom: 20px; font-size: 16px; font-weight: 600;">Properties</h3>
            <!-- Brush Properties -->
            <div id="brushProperties" style="display: none;">
                <div class="property-group">
                    <label class="property-label">Brush Color</label>
                    <div class="color-picker-wrapper">
                        <div class="color-swatch active" style="background: #ffffff;" data-color="#ffffff"></div>
                        <div class="color-swatch" style="background: #f85149;" data-color="#f85149"></div>
                        <div class="color-swatch" style="background: #3fb950;" data-color="#3fb950"></div>
                        <div class="color-swatch" style="background: #58a6ff;" data-color="#58a6ff"></div>
                        <div class="color-swatch" style="background: #d29922;" data-color="#d29922"></div>
                        <div class="color-swatch" style="background: #a371f7;" data-color="#a371f7"></div>
                        <div class="color-swatch" style="background: #ff7b72;" data-color="#ff7b72"></div>
                        <div class="color-swatch" style="background: #79c0ff;" data-color="#79c0ff"></div>
                    </div>
                </div>
                <div class="property-group">
                    <label class="property-label">Brush Size</label>
                    <input type="range" class="property-input" id="brushSize" min="1" max="20" value="3">
                    <div style="text-align: center; margin-top: 5px; font-size: 12px; color: var(--text-secondary);">
                        <span id="brushSizeValue">3</span>px
                    </div>
                </div>
                <div class="property-group">
                    <label class="property-label">Opacity</label>
                    <input type="range" class="property-input" id="brushOpacity" min="0" max="100" value="100">
                    <div style="text-align: center; margin-top: 5px; font-size: 12px; color: var(--text-secondary);">
                        <span id="brushOpacityValue">100</span>%
                    </div>
                </div>
            </div>
            <!-- Text Properties -->
            <div id="textProperties" style="display: none;">
                <div class="property-group">
                    <label class="property-label">Font Family</label>
                    <select class="property-input" id="fontFamily">
                        <option value="Arial">Arial</option>
                        <option value="Helvetica">Helvetica</option>
                        <option value="Georgia">Georgia</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="Courier New">Courier New</option>
                        <option value="Verdana">Verdana</option>
                        <option value="Comic Sans MS">Comic Sans MS</option>
                    </select>
                </div>
                <div class="property-group">
                    <label class="property-label">Font Size</label>
                    <input type="number" class="property-input" id="fontSize" value="16" min="8" max="72">
                </div>
                <div class="property-group">
                    <label class="property-label">Text Color</label>
                    <input type="color" class="property-input" id="textColor" value="#c9d1d9">
                </div>
                <div class="property-group">
                    <label class="property-label">Formatting</label>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn" id="boldBtn" style="flex: 1; font-weight: bold;">B</button>
                        <button class="btn" id="italicBtn" style="flex: 1; font-style: italic;">I</button>
                        <button class="btn" id="underlineBtn" style="flex: 1; text-decoration: underline;">U</button>
                    </div>
                </div>
            </div>
            <!-- Shape Properties -->
            <div id="shapeProperties" style="display: none;">
                <div class="property-group">
                    <label class="property-label">Shape Type</label>
                    <select class="property-input" id="shapeType">
                        <option value="process">Process</option>
                        <option value="decision">Decision</option>
                        <option value="terminator">Terminator</option>
                        <option value="data">Data</option>
                        <option value="rectangle">Rectangle</option>
                        <option value="circle">Circle</option>
                        <option value="triangle">Triangle</option>
                        <option value="diamond">Diamond</option>
                        <option value="arrow">Arrow</option>
                        <option value="cloud">Cloud</option>
                        <option value="sticky">Sticky Note</option>
                    </select>
                </div>
                <div class="property-group">
                    <label class="property-label">Fill Color</label>
                    <input type="color" class="property-input" id="shapeFillColor" value="#58a6ff">
                </div>
                <div class="property-group">
                    <label class="property-label">Stroke Color</label>
                    <input type="color" class="property-input" id="shapeStrokeColor" value="#ffffff">
                </div>
                <div class="property-group">
                    <label class="property-label">Stroke Width</label>
                    <input type="range" class="property-input" id="shapeStrokeWidth" min="0" max="10" value="2">
                </div>
            </div>
            <!-- Connector Properties -->
            <div id="connectorProperties" style="display: none;">
                 <div class="property-group">
                    <label class="property-label">Stroke Color</label>
                    <input type="color" class="property-input" id="connectorStrokeColor" value="#c9d1d9">
                </div>
                <div class="property-group">
                    <label class="property-label">Stroke Width</label>
                    <input type="range" class="property-input" id="connectorStrokeWidth" min="1" max="10" value="2">
                </div>
                 <div class="property-group">
                    <label class="property-label">Arrowheads</label>
                    <select class="property-input" id="connectorArrowheads">
                        <option value="end">End</option>
                        <option value="start">Start</option>
                        <option value="both">Both</option>
                        <option value="none">None</option>
                    </select>
                </div>
            </div>
            <!-- Code Properties -->
            <div id="codeProperties" style="display: none;">
                <div class="property-group">
                    <label class="property-label">Language</label>
                    <select class="property-input" id="codeLanguage">
                        <option value="javascript">JavaScript</option>
                        <option value="python">Python</option>
                        <option value="html">HTML</option>
                        <option value="css">CSS</option>
                        <option value="java">Java</option>
                        <option value="cpp">C++</option>
                        <option value="typescript">TypeScript</option>
                        <option value="rust">Rust</option>
                        <option value="go">Go</option>
                        <option value="ruby">Ruby</option>
                        <option value="php">PHP</option>
                        <option value="swift">Swift</option>
                    </select>
                </div>
                <div class="property-group">
                    <label class="property-label">Theme</label>
                    <select class="property-input" id="codeTheme">
                        <option value="dark">Dark</option>
                        <option value="light">Light</option>
                        <option value="monokai">Monokai</option>
                    </select>
                </div>
            </div>
            <!-- General Element Properties -->
            <div id="elementProperties" style="display: none;">
                <div class="property-group">
                    <label class="property-label">Layer Order</label>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn" id="bringToFrontBtn" style="flex: 1;">Bring to Front</button>
                        <button class="btn" id="sendToBackBtn" style="flex: 1;">Send to Back</button>
                    </div>
                </div>
                <div class="property-group">
                    <button class="btn btn-danger" id="deleteElementBtn">
                        Delete Element
                    </button>
                </div>
            </div>
        </div>
        <!-- Floating Action Button -->
        <div class="fab" id="fabMenu">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="12" y1="5" x2="12" y2="19"/>
                <line x1="5" y1="12" x2="19" y2="12"/>
            </svg>
        </div>
    </div>
    <!-- Project Manager Modal -->
    <div class="modal" id="projectModal">
        <div class="modal-content">
            <div class="modal-header">
                Project Manager
                <button class="modal-close">&times;</button>
            </div>
            <div class="modal-body">
                <div class="project-list" id="projectList"></div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="cancelProjectBtn">Cancel</button>
                <button class="btn btn-primary" id="loadProjectBtn">Load Project</button>
            </div>
        </div>
    </div>
    <!-- New Project Modal -->
    <div class="modal" id="newProjectModal">
        <div class="modal-content">
             <div class="modal-header">
                Create New Project
                <button class="modal-close">&times;</button>
            </div>
            <div class="modal-body">
                <div class="property-group">
                    <label class="property-label">Project Name</label>
                    <input type="text" class="property-input" id="newProjectName" placeholder="Enter project name...">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="cancelNewProjectBtn">Cancel</button>
                <button class="btn btn-primary" id="createProjectBtn">Create</button>
            </div>
        </div>
    </div>
    <script>
        // --- Global State ---
        const state = {
            currentTool: 'select',
            currentProject: null,
            projects: JSON.parse(localStorage.getItem('codecanvas_projects')) || {},
            canvas: {
                zoom: 1,
                panX: 0,
                panY: 0,
                elements: [],
                selectedElement: null
            },
            history: {
                undoStack: [],
                redoStack: []
            },
            brushSettings: {
                color: '#ffffff',
                size: 3,
                opacity: 1
            },
            textSettings: {
                fontFamily: 'Arial',
                fontSize: 16,
                color: '#c9d1d9',
                bold: false,
                italic: false,
                underline: false
            },
            shapeSettings: {
                type: 'rectangle',
                fillColor: '#58a6ff',
                strokeColor: '#ffffff',
                strokeWidth: 2
            },
            connectorSettings: {
                strokeColor: '#c9d1d9',
                strokeWidth: 2,
                arrowheads: 'end' // 'start', 'end', 'both', 'none'
            },
            codeSettings: {
                language: 'javascript',
                theme: 'dark'
            },
            isDrawing: false,
            isPanning: false,
            startPoint: null,
            currentPath: null,
            isCreatingConnector: false,
            connectorStartPoint: null,
            tempConnector: null
        };

        // --- Utility Functions ---
        function generateId() {
            return 'el_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        function getCursorForTool(tool) {
            switch(tool) {
                case 'select': return 'default';
                case 'brush':
                case 'eraser':
                case 'shape':
                case 'connector':
                case 'code': return 'crosshair';
                case 'text': return 'text';
                default: return 'default';
            }
        }

        function showNotification(message) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                bottom: 100px;
                left: 50%;
                transform: translateX(-50%);
                background: var(--bg-tertiary);
                color: var(--text-primary);
                padding: 12px 24px;
                border-radius: 8px;
                box-shadow: var(--shadow-lg);
                z-index: 10000;
                animation: fadeIn 0.3s ease;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);
            setTimeout(() => {
                notification.style.animation = 'fadeOut 0.3s ease';
                setTimeout(() => notification.remove(), 300);
            }, 2000);
        }

        // --- Canvas Transformations ---
        function updateCanvasTransform() {
            const canvas = document.getElementById('canvas');
            canvas.style.transform = `translate(${state.canvas.panX}px, ${state.canvas.panY}px) scale(${state.canvas.zoom})`;
        }

        function updateZoomDisplay() {
            document.getElementById('zoomLevel').textContent = Math.round(state.canvas.zoom * 100) + '%';
        }

        function zoom(factor, clientX, clientY) {
            const oldZoom = state.canvas.zoom;
            const containerRect = document.querySelector('.canvas-container').getBoundingClientRect();
            
            // Calculate mouse position relative to canvas before zoom
            const mouseX = (clientX - containerRect.left - state.canvas.panX) / oldZoom;
            const mouseY = (clientY - containerRect.top - state.canvas.panY) / oldZoom;

            state.canvas.zoom *= factor;
            state.canvas.zoom = Math.max(0.1, Math.min(5, state.canvas.zoom));

            // Adjust pan to keep mouse position fixed
            state.canvas.panX = clientX - containerRect.left - mouseX * state.canvas.zoom;
            state.canvas.panY = clientY - containerRect.top - mouseY * state.canvas.zoom;

            updateCanvasTransform();
            updateZoomDisplay();
        }

        function resetZoom() {
            state.canvas.zoom = 1;
            const container = document.querySelector('.canvas-container');
            state.canvas.panX = (container.clientWidth - 5000) / 2;
            state.canvas.panY = (container.clientHeight - 5000) / 2;
            updateCanvasTransform();
            updateZoomDisplay();
        }

        function toggleGrid() {
            const canvas = document.getElementById('canvas');
            canvas.classList.toggle('no-grid');
        }


        // --- History Management ---
        function saveToHistory() {
            // Debounce saving to prevent excessive snapshots
            if (state.history._saveTimeout) {
                clearTimeout(state.history._saveTimeout);
            }
            state.history._saveTimeout = setTimeout(() => {
                const snapshot = {
                    elements: state.canvas.elements.map(el => {
                        let content = '';
                        if (el.type === 'text') {
                            content = el.element.value;
                        } else if (el.type === 'code') {
                            content = el.element.querySelector('code').textContent;
                        } else {
                            content = el.element.innerHTML;
                        }
                        return {
                            type: el.type,
                            id: el.id,
                            x: el.x,
                            y: el.y,
                            content: content,
                            style: el.element.getAttribute('style'),
                            attributes: getElementAttributes(el)
                        };
                    })
                };
                state.history.undoStack.push(JSON.stringify(snapshot));
                state.history.redoStack = [];
                if (state.history.undoStack.length > 50) {
                    state.history.undoStack.shift();
                }
                delete state.history._saveTimeout; // Clear timeout reference
            }, 100); // 100ms debounce
        }

        function getElementAttributes(element) {
            const attrs = {};
            if (element.type === 'shape') {
                attrs.shapeType = element.shapeType;
                attrs.width = element.width;
                attrs.height = element.height;
            } else if (element.type === 'code') {
                attrs.language = element.language;
                attrs.theme = element.theme;
            } else if (element.type === 'connector') {
                 attrs.startElementId = element.startElementId;
                 attrs.endElementId = element.endElementId;
                 attrs.startPoint = element.startPoint;
                 attrs.endPoint = element.endPoint;
                 attrs.label = element.label;
                 attrs.pathData = element.pathData;
                 attrs.strokeColor = element.strokeColor;
                 attrs.strokeWidth = element.strokeWidth;
                 attrs.arrowheads = element.arrowheads;
            }
            return attrs;
        }

        function undo() {
            if (state.history.undoStack.length === 0) return;
            const current = JSON.stringify({
                elements: state.canvas.elements.map(el => {
                     let content = '';
                        if (el.type === 'text') {
                            content = el.element.value;
                        } else if (el.type === 'code') {
                            content = el.element.querySelector('code').textContent;
                        } else {
                            content = el.element.innerHTML;
                        }
                    return {
                        type: el.type,
                        id: el.id,
                        x: el.x,
                        y: el.y,
                        content: content,
                        style: el.element.getAttribute('style'),
                        attributes: getElementAttributes(el)
                    };
                })
            });
            state.history.redoStack.push(current);
            const snapshot = JSON.parse(state.history.undoStack.pop());
            restoreSnapshot(snapshot);
        }

        function redo() {
            if (state.history.redoStack.length === 0) return;
            const snapshot = JSON.parse(state.history.redoStack.pop());
            restoreSnapshot(snapshot);
            // After redo, save the current state to history
            saveToHistory();
        }

        function restoreSnapshot(snapshot) {
            // Clear canvas
            state.canvas.elements.forEach(el => {
                if (el.element && el.element.parentNode) {
                    el.element.parentNode.removeChild(el.element);
                }
            });
            state.canvas.elements = [];
            state.canvas.selectedElement = null;
            document.getElementById('elementProperties').style.display = 'none';

            // Restore elements
            snapshot.elements.forEach(data => {
                let element, canvasElement;
                switch(data.type) {
                    case 'drawing':
                        element = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                        element.style.cssText = data.style;
                        element.innerHTML = data.content;
                        element.classList.add('canvas-element');
                        canvasElement = {
                            type: 'drawing',
                            element: element,
                            id: data.id,
                            x: data.x,
                            y: data.y
                        };
                        break;
                    case 'text':
                        element = document.createElement('textarea');
                        element.className = 'text-element canvas-element';
                        element.style.cssText = data.style;
                        element.value = data.content;
                        canvasElement = {
                            type: 'text',
                            element: element,
                            id: data.id,
                            x: data.x,
                            y: data.y
                        };
                        break;
                     case 'shape':
                        element = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                        element.style.cssText = data.style;
                        element.innerHTML = data.content;
                        element.classList.add('canvas-element', 'shape-element');
                        canvasElement = {
                            type: 'shape',
                            element: element,
                            id: data.id,
                            x: data.x,
                            y: data.y,
                            shapeType: data.attributes.shapeType,
                            width: data.attributes.width || 100,
                            height: data.attributes.height || 100
                        };
                        break;
                    case 'code':
                        element = document.createElement('pre');
                        const codeEl = document.createElement('code');
                        element.className = 'code-element canvas-element';
                        element.style.cssText = data.style;
                        codeEl.textContent = data.content;
                        element.appendChild(codeEl);
                        canvasElement = {
                            type: 'code',
                            element: element,
                            id: data.id,
                            x: data.x,
                            y: data.y,
                            language: data.attributes.language,
                            theme: data.attributes.theme
                        };
                        // Apply theme and highlight
                        applyCodeTheme(element, data.attributes.theme);
                        applyCodeLanguage(element, data.attributes.language);
                        break;
                    case 'connector':
                         // Recreate SVG for connector
                        element = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                        element.style.cssText = data.style;
                        element.classList.add('canvas-element', 'connector-element');
                        element.innerHTML = data.content; // This includes path and label
                        
                        canvasElement = {
                            type: 'connector',
                            element: element,
                            id: data.id,
                            x: data.x, // Not typically used for connectors, but kept for consistency
                            y: data.y,
                            startElementId: data.attributes.startElementId,
                            endElementId: data.attributes.endElementId,
                            startPoint: data.attributes.startPoint,
                            endPoint: data.attributes.endPoint,
                            label: data.attributes.label,
                            pathData: data.attributes.pathData,
                            strokeColor: data.attributes.strokeColor || state.connectorSettings.strokeColor,
                            strokeWidth: data.attributes.strokeWidth || state.connectorSettings.strokeWidth,
                            arrowheads: data.attributes.arrowheads || state.connectorSettings.arrowheads
                        };
                        break;
                }
                if (element) {
                    document.getElementById('canvas').appendChild(element);
                    state.canvas.elements.push(canvasElement);
                    
                    // Re-attach event listeners
                    if (data.type === 'text') {
                        element.addEventListener('mousedown', (e) => {
                            if (state.currentTool === 'select') {
                                selectElement(canvasElement);
                                e.stopPropagation();
                            }
                        });
                        element.addEventListener('input', saveToHistory);
                    } else if (data.type === 'code') {
                        const codeEl = element.querySelector('code');
                        codeEl.addEventListener('input', () => {
                            applyCodeLanguage(element, canvasElement.language);
                            saveToHistory();
                        });
                        element.addEventListener('mousedown', (e) => {
                            if (state.currentTool === 'select') {
                                selectElement(canvasElement);
                                e.stopPropagation();
                            }
                        });
                    } else if (data.type === 'shape') {
                         element.addEventListener('mousedown', (e) => {
                            if (state.currentTool === 'select') {
                                selectElement(canvasElement);
                                startDragging(e, canvasElement);
                                e.stopPropagation();
                            } else if (state.currentTool === 'connector') {
                                // Handle connector start point on shape
                                startConnectorFromShape(e, canvasElement);
                                e.stopPropagation();
                            }
                        });
                    } else if(data.type === 'connector') {
                         element.addEventListener('mousedown', (e) => {
                            if (state.currentTool === 'select') {
                                selectElement(canvasElement);
                                e.stopPropagation();
                            }
                        });
                        // Re-add label double-click listener if label exists
                        const labelEl = element.querySelector('.connector-label');
                        if(labelEl) {
                             labelEl.addEventListener('dblclick', (e) => {
                                e.stopPropagation();
                                editConnectorLabel(canvasElement, labelEl);
                            });
                        }
                    } else {
                        element.addEventListener('mousedown', (e) => {
                            if (state.currentTool === 'select') {
                                selectElement(canvasElement);
                                if (data.type !== 'drawing') { // Don't drag drawings
                                    startDragging(e, canvasElement);
                                }
                                e.stopPropagation();
                            }
                        });
                    }
                }
            });
            updatePropertiesPanel(); // Update panel based on new state
        }


        // --- Element Creation and Manipulation ---
        function selectTool(tool) {
            state.currentTool = tool;
            document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[data-tool="${tool}"]`).classList.add('active');
            updatePropertiesPanel();
            const canvas = document.getElementById('canvas');
            canvas.style.cursor = getCursorForTool(tool);
            
            // Reset connector creation state if switching tools
            if (tool !== 'connector') {
                state.isCreatingConnector = false;
                state.connectorStartPoint = null;
                if (state.tempConnector) {
                    state.tempConnector.remove();
                    state.tempConnector = null;
                }
            }
        }

        function updatePropertiesPanel() {
            document.getElementById('brushProperties').style.display = 'none';
            document.getElementById('textProperties').style.display = 'none';
            document.getElementById('shapeProperties').style.display = 'none';
            document.getElementById('connectorProperties').style.display = 'none';
            document.getElementById('codeProperties').style.display = 'none';
            document.getElementById('elementProperties').style.display = 'none';

            switch(state.currentTool) {
                case 'brush':
                case 'eraser':
                    document.getElementById('brushProperties').style.display = 'block';
                    break;
                case 'text':
                    document.getElementById('textProperties').style.display = 'block';
                    break;
                case 'shape':
                    document.getElementById('shapeProperties').style.display = 'block';
                    break;
                case 'connector':
                    document.getElementById('connectorProperties').style.display = 'block';
                    break;
                case 'code':
                    document.getElementById('codeProperties').style.display = 'block';
                    break;
            }

            if (state.canvas.selectedElement) {
                document.getElementById('elementProperties').style.display = 'block';
                // Show specific properties for the selected element type
                if (state.canvas.selectedElement.type === 'text') {
                    document.getElementById('textProperties').style.display = 'block';
                } else if (state.canvas.selectedElement.type === 'shape') {
                    document.getElementById('shapeProperties').style.display = 'block';
                } else if (state.canvas.selectedElement.type === 'connector') {
                    document.getElementById('connectorProperties').style.display = 'block';
                } else if (state.canvas.selectedElement.type === 'code') {
                    document.getElementById('codeProperties').style.display = 'block';
                }
            }
        }

        function deselectAll() {
            document.querySelectorAll('.canvas-element').forEach(el => el.classList.remove('selected'));
            state.canvas.selectedElement = null;
            updatePropertiesPanel();
        }

        function selectElement(element) {
            deselectAll();
            element.element.classList.add('selected');
            state.canvas.selectedElement = element;
            updatePropertiesPanel();
        }

        function deleteSelectedElement() {
            if (!state.canvas.selectedElement) return;
            const index = state.canvas.elements.indexOf(state.canvas.selectedElement);
            if (index > -1) {
                state.canvas.selectedElement.element.remove();
                state.canvas.elements.splice(index, 1);
                state.canvas.selectedElement = null;
                updatePropertiesPanel();
                saveToHistory();
            }
        }

        function changeElementOrder(direction) {
            if (!state.canvas.selectedElement) return;
            const element = state.canvas.selectedElement.element;
            let newZ;
            if (direction === 'front') {
                // Find the current highest z-index and go one higher
                let maxZ = 0;
                state.canvas.elements.forEach(el => {
                   const z = parseInt(window.getComputedStyle(el.element).zIndex) || 0;
                   if (z > maxZ) maxZ = z;
                });
                newZ = maxZ + 1;
            } else { // back
                 // Find the current lowest z-index and go one lower
                let minZ = 0;
                state.canvas.elements.forEach(el => {
                   const z = parseInt(window.getComputedStyle(el.element).zIndex) || 0;
                   if (z < minZ) minZ = z;
                });
                newZ = minZ - 1;
            }
            element.style.zIndex = newZ;
            saveToHistory();
        }

        function startDragging(e, element) {
            e.preventDefault();
            const startX = e.clientX;
            const startY = e.clientY;
            const startLeft = parseFloat(element.element.style.left) || 0;
            const startTop = parseFloat(element.element.style.top) || 0;

            function handleDrag(e) {
                const dx = (e.clientX - startX) / state.canvas.zoom;
                const dy = (e.clientY - startY) / state.canvas.zoom;
                element.element.style.left = (startLeft + dx) + 'px';
                element.element.style.top = (startTop + dy) + 'px';
                element.x = startLeft + dx;
                element.y = startTop + dy;
                
                // If it's a shape, update any connectors attached to it
                if (element.type === 'shape') {
                    updateConnectedConnectors(element);
                }
            }

            function stopDrag() {
                document.removeEventListener('mousemove', handleDrag);
                document.removeEventListener('mouseup', stopDrag);
                saveToHistory();
            }

            document.addEventListener('mousemove', handleDrag);
            document.addEventListener('mouseup', stopDrag);
        }

        // --- Drawing Tools ---
        function startDrawing(x, y) {
            state.isDrawing = true;
            const svg = createSVGElement();
            state.currentPath = svg;
            state.canvas.elements.push({
                type: 'drawing',
                element: svg,
                id: generateId()
            });
            document.getElementById('canvas').appendChild(svg);
        }

        function drawLine(x1, y1, x2, y2) {
            if (!state.currentPath) return;
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', x1);
            line.setAttribute('y1', y1);
            line.setAttribute('x2', x2);
            line.setAttribute('y2', y2);
            line.setAttribute('stroke', state.brushSettings.color);
            line.setAttribute('stroke-width', state.brushSettings.size);
            line.setAttribute('stroke-opacity', state.brushSettings.opacity);
            line.setAttribute('stroke-linecap', 'round');
            state.currentPath.appendChild(line);
        }

        function startErasing(x, y) {
            const originalColor = state.brushSettings.color;
            state.brushSettings.color = '#0d1117';
            startDrawing(x, y);
            setTimeout(() => {
                state.brushSettings.color = originalColor;
            }, 0);
        }

        function eraseLine(x1, y1, x2, y2) {
            const originalColor = state.brushSettings.color;
            state.brushSettings.color = '#0d1117';
            drawLine(x1, y1, x2, y2);
            state.brushSettings.color = originalColor;
        }

        function createSVGElement() {
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;';
            svg.classList.add('canvas-element');
            return svg;
        }

        // --- Text Tool ---
        function createTextElement(x, y) {
            const textarea = document.createElement('textarea');
            textarea.className = 'text-element canvas-element';
            textarea.style.left = x + 'px';
            textarea.style.top = y + 'px';
            textarea.style.fontFamily = state.textSettings.fontFamily;
            textarea.style.fontSize = state.textSettings.fontSize + 'px';
            textarea.style.color = state.textSettings.color;
            textarea.style.fontWeight = state.textSettings.bold ? 'bold' : 'normal';
            textarea.style.fontStyle = state.textSettings.italic ? 'italic' : 'normal';
            textarea.style.textDecoration = state.textSettings.underline ? 'underline' : 'none';
            textarea.placeholder = 'Type here...';

            const element = {
                type: 'text',
                element: textarea,
                id: generateId(),
                x: x,
                y: y
            };

            state.canvas.elements.push(element);
            document.getElementById('canvas').appendChild(textarea);
            textarea.focus();

            textarea.addEventListener('mousedown', (e) => {
                if (state.currentTool === 'select') {
                    selectElement(element);
                    e.stopPropagation();
                }
            });
            textarea.addEventListener('input', saveToHistory);

            selectElement(element);
            saveToHistory();
        }

        // --- Shape Tool ---
        function createShapeElement(x, y) {
            const width = 100;
            const height = 60; // Default height for flowchart shapes
            let shapeSVG, shapePathData;

            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.style.cssText = `position: absolute; left: ${x}px; top: ${y}px; width: ${width}px; height: ${height}px;`;
            svg.classList.add('canvas-element', 'shape-element');

            switch(state.shapeSettings.type) {
                case 'process': // Rectangle
                    shapeSVG = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    shapeSVG.setAttribute('width', width);
                    shapeSVG.setAttribute('height', height);
                    shapeSVG.setAttribute('rx', '6');
                    shapePathData = `M0,0 L${width},0 L${width},${height} L0,${height} Z`;
                    break;
                case 'decision': // Diamond
                    shapeSVG = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    const points = `${width/2},0 ${width},${height/2} ${width/2},${height} 0,${height/2}`;
                    shapeSVG.setAttribute('points', points);
                    shapePathData = `M${width/2},0 L${width},${height/2} L${width/2},${height} L0,${height/2} Z`;
                    // Adjust SVG size for diamond
                    svg.style.width = width + 'px';
                    svg.style.height = height + 'px';
                    break;
                case 'terminator': // Rounded Rectangle (like process but more rounded)
                    shapeSVG = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    shapeSVG.setAttribute('width', width);
                    shapeSVG.setAttribute('height', height);
                    shapeSVG.setAttribute('rx', '20'); // More rounded
                    shapePathData = `M20,0 H${width-20} Q${width},0 ${width},20 V${height-20} Q${width},${height} ${width-20},${height} H20 Q0,${height} 0,${height-20} V20 Q0,0 20,0 Z`;
                    break;
                case 'data': // Parallelogram
                    shapeSVG = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    const offset = 15;
                    const pPoints = `${offset},0 ${width},0 ${width-offset},${height} 0,${height}`;
                    shapeSVG.setAttribute('points', pPoints);
                    shapePathData = `M${offset},0 L${width},0 L${width-offset},${height} L0,${height} Z`;
                    break;
                 case 'rectangle':
                    shapeSVG = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    shapeSVG.setAttribute('width', width);
                    shapeSVG.setAttribute('height', height);
                    shapeSVG.setAttribute('rx', '4');
                    shapePathData = `M0,0 L${width},0 L${width},${height} L0,${height} Z`;
                    break;
                case 'circle':
                    shapeSVG = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    shapeSVG.setAttribute('cx', width/2);
                    shapeSVG.setAttribute('cy', height/2);
                    shapeSVG.setAttribute('r', Math.min(width, height)/2);
                    shapePathData = `M${width/2},${height/2} m-${Math.min(width, height)/2},0 a${Math.min(width, height)/2},${Math.min(width, height)/2} 0 1,0 ${Math.min(width, height)},0 a${Math.min(width, height)/2},${Math.min(width, height)/2} 0 1,0 -${Math.min(width, height)},0`;
                    break;
                case 'triangle':
                    shapeSVG = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    shapeSVG.setAttribute('points', `${width/2},0 ${width},${height} 0,${height}`);
                    shapePathData = `M${width/2},0 L${width},${height} L0,${height} Z`;
                    break;
                case 'diamond':
                    shapeSVG = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    shapeSVG.setAttribute('points', `${width/2},0 ${width},${height/2} ${width/2},${height} 0,${height/2}`);
                    shapePathData = `M${width/2},0 L${width},${height/2} L${width/2},${height} L0,${height/2} Z`;
                    break;
                case 'arrow':
                    shapeSVG = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    shapeSVG.setAttribute('d', 'M10,30 L60,30 L60,10 L90,40 L60,70 L60,50 L10,50 Z');
                    shapePathData = 'M10,30 L60,30 L60,10 L90,40 L60,70 L60,50 L10,50 Z';
                    // Adjust size for arrow
                    svg.style.width = '100px';
                    svg.style.height = '80px';
                    break;
                case 'cloud':
                    shapeSVG = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    // Simplified cloud path
                    shapeSVG.setAttribute('d', 'M25,60 Q15,60 15,50 Q15,35 30,35 Q30,25 40,25 Q50,25 55,30 Q65,20 75,25 Q85,30 85,40 Q90,45 90,55 Q90,65 80,65 Q85,70 75,70 Q70,75 60,70 Q50,75 40,70 Q30,75 25,70 Q15,70 20,65 Z');
                    shapePathData = 'M25,60 Q15,60 15,50 Q15,35 30,35 Q30,25 40,25 Q50,25 55,30 Q65,20 75,25 Q85,30 85,40 Q90,45 90,55 Q90,65 80,65 Q85,70 75,70 Q70,75 60,70 Q50,75 40,70 Q30,75 25,70 Q15,70 20,65 Z';
                    svg.style.width = '100px';
                    svg.style.height = '80px';
                    break;
                case 'sticky':
                    shapeSVG = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    shapeSVG.setAttribute('d', 'M0,15 Q0,0 15,0 L85,0 Q100,0 100,15 L100,85 Q100,100 85,100 L15,100 Q0,100 0,85 Z');
                    shapePathData = 'M0,15 Q0,0 15,0 L85,0 Q100,0 100,15 L100,85 Q100,100 85,100 L15,100 Q0,100 0,85 Z';
                    svg.style.width = '100px';
                    svg.style.height = '100px';
                    state.shapeSettings.fillColor = '#d29922'; // Override color
                    break;
            }

            shapeSVG.setAttribute('fill', state.shapeSettings.fillColor);
            shapeSVG.setAttribute('stroke', state.shapeSettings.strokeColor);
            shapeSVG.setAttribute('stroke-width', state.shapeSettings.strokeWidth);
            shapeSVG.classList.add('flowchart-shape'); // Add class for styling/interaction

            svg.appendChild(shapeSVG);

            // Store connection points (simplified: center of edges)
            const connectionPoints = [];
            if (['process', 'terminator', 'data', 'rectangle'].includes(state.shapeSettings.type)) {
                 connectionPoints.push({x: width/2, y: 0, id: 'top'});
                 connectionPoints.push({x: width, y: height/2, id: 'right'});
                 connectionPoints.push({x: width/2, y: height, id: 'bottom'});
                 connectionPoints.push({x: 0, y: height/2, id: 'left'});
            } else if (state.shapeSettings.type === 'decision') {
                 connectionPoints.push({x: width/2, y: 0, id: 'top'});
                 connectionPoints.push({x: width, y: height/2, id: 'right'});
                 connectionPoints.push({x: width/2, y: height, id: 'bottom'});
                 connectionPoints.push({x: 0, y: height/2, id: 'left'});
            } else if (state.shapeSettings.type === 'circle') {
                 connectionPoints.push({x: width/2, y: 0, id: 'top'});
                 connectionPoints.push({x: width, y: height/2, id: 'right'});
                 connectionPoints.push({x: width/2, y: height, id: 'bottom'});
                 connectionPoints.push({x: 0, y: height/2, id: 'left'});
            } else {
                // Default center points if shape is complex
                connectionPoints.push({x: width/2, y: 0, id: 'top'});
                connectionPoints.push({x: width, y: height/2, id: 'right'});
                connectionPoints.push({x: width/2, y: height, id: 'bottom'});
                connectionPoints.push({x: 0, y: height/2, id: 'left'});
            }

            // Create small visual connection points
            connectionPoints.forEach(point => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.classList.add('connector-point');
                circle.setAttribute('cx', point.x);
                circle.setAttribute('cy', point.y);
                circle.setAttribute('r', 4);
                circle.setAttribute('data-point-id', point.id);
                circle.style.display = 'none'; // Hidden by default
                svg.appendChild(circle);
            });

            // Show connection points on hover
            svg.addEventListener('mouseenter', () => {
                svg.querySelectorAll('.connector-point').forEach(p => p.style.display = 'block');
            });
            svg.addEventListener('mouseleave', () => {
                // Only hide if not in connector creation mode
                if (!state.isCreatingConnector || state.connectorStartPoint?.elementId !== svg.parentNode.id) {
                    svg.querySelectorAll('.connector-point').forEach(p => p.style.display = 'none');
                }
            });

            const element = {
                type: 'shape',
                element: svg,
                id: generateId(),
                x: x,
                y: y,
                shapeType: state.shapeSettings.type,
                width: width,
                height: height,
                connectionPoints: connectionPoints,
                pathData: shapePathData // Store path data for potential use
            };

            // Assign ID to the SVG element for referencing
            svg.id = element.id;

            state.canvas.elements.push(element);
            document.getElementById('canvas').appendChild(svg);

            svg.addEventListener('mousedown', (e) => {
                if (state.currentTool === 'select') {
                    selectElement(element);
                    startDragging(e, element);
                    e.stopPropagation();
                } else if (state.currentTool === 'connector') {
                    startConnectorFromShape(e, element);
                    e.stopPropagation();
                }
            });

            selectElement(element);
            saveToHistory();
        }

        // --- Connector Tool ---
        function startConnectorFromShape(e, shapeElement) {
            const rect = shapeElement.element.getBoundingClientRect();
            const canvasRect = document.getElementById('canvas').getBoundingClientRect();
            
            // Get the local click position within the shape
            const localX = (e.clientX - canvasRect.left) / state.canvas.zoom - state.canvas.panX / state.canvas.zoom - shapeElement.x;
            const localY = (e.clientY - canvasRect.top) / state.canvas.zoom - state.canvas.panY / state.canvas.zoom - shapeElement.y;
            
            // Find the closest connection point
            let closestPoint = null;
            let minDist = Infinity;
            shapeElement.connectionPoints.forEach(point => {
                const dx = point.x - localX;
                const dy = point.y - localY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < minDist && dist < 20) { // 20px threshold
                    minDist = dist;
                    closestPoint = point;
                }
            });
            
            if (closestPoint) {
                state.isCreatingConnector = true;
                state.connectorStartPoint = {
                    elementId: shapeElement.id,
                    pointId: closestPoint.id,
                    x: shapeElement.x + closestPoint.x,
                    y: shapeElement.y + closestPoint.y
                };
                // Create temporary connector line
                const svgNS = "http://www.w3.org/2000/svg";
                const tempSVG = document.createElementNS(svgNS, 'svg');
                tempSVG.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5;';
                tempSVG.classList.add('canvas-element');
                const tempPath = document.createElementNS(svgNS, 'path');
                tempPath.setAttribute('d', `M ${state.connectorStartPoint.x} ${state.connectorStartPoint.y} L ${state.connectorStartPoint.x} ${state.connectorStartPoint.y}`);
                tempPath.setAttribute('fill', 'none');
                tempPath.setAttribute('stroke', state.connectorSettings.strokeColor);
                tempPath.setAttribute('stroke-width', state.connectorSettings.strokeWidth);
                if (state.connectorSettings.arrowheads === 'end' || state.connectorSettings.arrowheads === 'both') {
                    tempPath.setAttribute('marker-end', 'url(#arrowhead)');
                }
                tempSVG.appendChild(tempPath);
                document.getElementById('canvas').appendChild(tempSVG);
                state.tempConnector = tempSVG;
            }
        }

        function updateTempConnector(endX, endY) {
            if (!state.tempConnector || !state.connectorStartPoint) return;
            const path = state.tempConnector.querySelector('path');
            if (path) {
                // Create an orthogonal path
                const startX = state.connectorStartPoint.x;
                const startY = state.connectorStartPoint.y;
                const midX = (startX + endX) / 2;
                const pathData = `M ${startX} ${startY} L ${midX} ${startY} L ${midX} ${endY} L ${endX} ${endY}`;
                path.setAttribute('d', pathData);
            }
        }

        function finishConnector(endX, endY, endElement = null, endPointId = null) {
             if (!state.connectorStartPoint) return;

            let endConnectorPoint = { x: endX, y: endY };
            if (endElement && endPointId) {
                // If ending on a shape, get the exact connection point
                const endPoint = endElement.connectionPoints.find(p => p.id === endPointId);
                if (endPoint) {
                    endConnectorPoint.x = endElement.x + endPoint.x;
                    endConnectorPoint.y = endElement.y + endPoint.y;
                }
            }

            // Create the final connector element
            const svgNS = "http://www.w3.org/2000/svg";
            const connectorSVG = document.createElementNS(svgNS, 'svg');
            connectorSVG.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;'; // pointer-events initially none for path
            connectorSVG.classList.add('canvas-element', 'connector-element');

            const path = document.createElementNS(svgNS, 'path');
            path.classList.add('connector-path');
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke', state.connectorSettings.strokeColor);
            path.setAttribute('stroke-width', state.connectorSettings.strokeWidth);
            
            // Set marker based on arrowhead setting
            if (state.connectorSettings.arrowheads === 'end' || state.connectorSettings.arrowheads === 'both') {
                path.setAttribute('marker-end', 'url(#arrowhead)');
            }
            if (state.connectorSettings.arrowheads === 'start' || state.connectorSettings.arrowheads === 'both') {
                path.setAttribute('marker-start', 'url(#arrowhead)'); // Need to define start marker in defs
            }
            
            connectorSVG.appendChild(path);

            // Initial orthogonal path
            const startX = state.connectorStartPoint.x;
            const startY = state.connectorStartPoint.y;
            const endXFinal = endConnectorPoint.x;
            const endYFinal = endConnectorPoint.y;
            const midX = (startX + endXFinal) / 2;
            const pathData = `M ${startX} ${startY} L ${midX} ${startY} L ${midX} ${endYFinal} L ${endXFinal} ${endYFinal}`;
            path.setAttribute('d', pathData);

            const connectorElement = {
                type: 'connector',
                element: connectorSVG,
                id: generateId(),
                startElementId: state.connectorStartPoint.elementId,
                endElementId: endElement ? endElement.id : null,
                startPoint: { x: startX, y: startY },
                endPoint: { x: endXFinal, y: endYFinal },
                label: '',
                pathData: pathData,
                strokeColor: state.connectorSettings.strokeColor,
                strokeWidth: state.connectorSettings.strokeWidth,
                arrowheads: state.connectorSettings.arrowheads
            };

            connectorSVG.id = connectorElement.id;

            state.canvas.elements.push(connectorElement);
            document.getElementById('canvas').appendChild(connectorSVG);

            // Make the path itself clickable for selection
            path.style.pointerEvents = 'all';
            path.style.cursor = 'pointer';
            path.addEventListener('mousedown', (e) => {
                if (state.currentTool === 'select') {
                    selectElement(connectorElement);
                    e.stopPropagation();
                }
            });

            // Add double-click to edit label
            path.addEventListener('dblclick', (e) => {
                createConnectorLabel(connectorElement, e.clientX, e.clientY);
                e.stopPropagation();
            });

            selectElement(connectorElement);
            saveToHistory();

            // Cleanup
            state.isCreatingConnector = false;
            state.connectorStartPoint = null;
            if (state.tempConnector) {
                state.tempConnector.remove();
                state.tempConnector = null;
            }
        }

        function createConnectorLabel(connectorElement, clientX, clientY) {
            const label = prompt('Enter label:', connectorElement.label || '');
            if (label !== null) { // null if cancelled
                connectorElement.label = label;
                updateConnectorLabel(connectorElement, clientX, clientY);
            }
        }

        function updateConnectorLabel(connectorElement, clientX, clientY) {
            // Remove existing label if any
            const existingLabel = connectorElement.element.querySelector('.connector-label');
            if (existingLabel) {
                existingLabel.remove();
            }

            if (connectorElement.label) {
                const svgNS = "http://www.w3.org/2000/svg";
                const labelEl = document.createElementNS(svgNS, 'text');
                labelEl.classList.add('connector-label');
                labelEl.setAttribute('x', clientX / state.canvas.zoom - state.canvas.panX / state.canvas.zoom);
                labelEl.setAttribute('y', clientY / state.canvas.zoom - state.canvas.panY / state.canvas.zoom - 5); // Slightly above click
                labelEl.textContent = connectorElement.label;
                
                // Add background for better readability
                const bbox = labelEl.getBBox();
                const padding = 2;
                const bg = document.createElementNS(svgNS, 'rect');
                bg.setAttribute('x', bbox.x - padding);
                bg.setAttribute('y', bbox.y - padding);
                bg.setAttribute('width', bbox.width + 2 * padding);
                bg.setAttribute('height', bbox.height + 2 * padding);
                bg.setAttribute('fill', 'var(--bg-secondary)');
                bg.setAttribute('rx', '2');
                // Insert background before text
                connectorElement.element.insertBefore(bg, connectorElement.element.firstChild);
                connectorElement.element.appendChild(labelEl);
                
                // Add double-click to edit
                labelEl.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    editConnectorLabel(connectorElement, labelEl);
                });
            }
        }
        
        function editConnectorLabel(connectorElement, labelElement) {
             const label = prompt('Edit label:', connectorElement.label || '');
             if (label !== null) {
                connectorElement.label = label;
                // Get position before removing
                const x = labelElement.getAttribute('x');
                const y = parseFloat(labelElement.getAttribute('y')) + 5; // Adjust back
                labelElement.remove();
                const bg = labelElement.previousElementSibling;
                if (bg && bg.tagName === 'rect') bg.remove();
                
                if (label) {
                    const svgNS = "http://www.w3.org/2000/svg";
                    const newLabelEl = document.createElementNS(svgNS, 'text');
                    newLabelEl.classList.add('connector-label');
                    newLabelEl.setAttribute('x', x);
                    newLabelEl.setAttribute('y', y);
                    newLabelEl.textContent = label;
                    
                    const bbox = newLabelEl.getBBox();
                    const padding = 2;
                    const bg = document.createElementNS(svgNS, 'rect');
                    bg.setAttribute('x', bbox.x - padding);
                    bg.setAttribute('y', bbox.y - padding);
                    bg.setAttribute('width', bbox.width + 2 * padding);
                    bg.setAttribute('height', bbox.height + 2 * padding);
                    bg.setAttribute('fill', 'var(--bg-secondary)');
                    bg.setAttribute('rx', '2');
                    connectorElement.element.insertBefore(bg, connectorElement.element.firstChild);
                    connectorElement.element.appendChild(newLabelEl);
                    
                    newLabelEl.addEventListener('dblclick', (e) => {
                        e.stopPropagation();
                        editConnectorLabel(connectorElement, newLabelEl);
                    });
                }
                saveToHistory();
             }
        }

        function updateConnectedConnectors(shapeElement) {
            // Find connectors attached to this shape
            state.canvas.elements.forEach(el => {
                if (el.type === 'connector' && (el.startElementId === shapeElement.id || el.endElementId === shapeElement.id)) {
                    let updatedStartPoint = el.startPoint;
                    let updatedEndPoint = el.endPoint;
                    
                    if (el.startElementId === shapeElement.id) {
                        // Update start point based on shape's new position and connection point
                        const startPointDef = shapeElement.connectionPoints.find(p => p.id === el.startPoint.id); // Need to store point ID in connector
                        if (startPointDef) {
                            updatedStartPoint = {
                                x: shapeElement.x + startPointDef.x,
                                y: shapeElement.y + startPointDef.y,
                                id: startPointDef.id // Store ID for future updates
                            };
                        }
                    }
                    if (el.endElementId === shapeElement.id) {
                        const endPointDef = shapeElement.connectionPoints.find(p => p.id === el.endPoint.id);
                        if (endPointDef) {
                            updatedEndPoint = {
                                x: shapeElement.x + endPointDef.x,
                                y: shapeElement.y + endPointDef.y,
                                id: endPointDef.id
                            };
                        }
                    }
                    
                    // Update the path
                    const path = el.element.querySelector('.connector-path');
                    if (path) {
                        const startX = updatedStartPoint.x;
                        const startY = updatedStartPoint.y;
                        const endX = updatedEndPoint.x;
                        const endY = updatedEndPoint.y;
                        const midX = (startX + endX) / 2;
                        const newPathData = `M ${startX} ${startY} L ${midX} ${startY} L ${midX} ${endY} L ${endX} ${endY}`;
                        path.setAttribute('d', newPathData);
                        el.startPoint = updatedStartPoint;
                        el.endPoint = updatedEndPoint;
                        el.pathData = newPathData;
                    }
                }
            });
        }

        // --- Code Snippet Tool ---
        function createCodeElement(x, y) {
            const pre = document.createElement('pre');
            const code = document.createElement('code');
            pre.className = 'code-element canvas-element';
            pre.style.left = x + 'px';
            pre.style.top = y + 'px';
            
            // Set initial content based on selected language
            let defaultContent = '';
            switch(state.codeSettings.language) {
                case 'javascript':
                    defaultContent = `// JavaScript Example\nfunction greet(name) {\n  console.log("Hello, " + name + "!");\n}\ngreet("CodeCanvas");`;
                    break;
                case 'python':
                    defaultContent = `# Python Example\ndef greet(name):\n    print(f"Hello, {name}!")\n\ngreet("CodeCanvas")`;
                    break;
                case 'html':
                    defaultContent = `<!-- HTML Example -->\n<div class="container">\n  <h1>Hello, CodeCanvas!</h1>\n</div>`;
                    break;
                case 'css':
                    defaultContent = `/* CSS Example */\n.container {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}`;
                    break;
                default:
                    defaultContent = `// ${state.codeSettings.language} code\n// Add your code here`;
            }
            code.textContent = defaultContent;

            applyCodeTheme(pre, state.codeSettings.theme);
            applyCodeLanguage(pre, state.codeSettings.language);

            pre.appendChild(code);

            const element = {
                type: 'code',
                element: pre,
                id: generateId(),
                x: x,
                y: y,
                language: state.codeSettings.language,
                theme: state.codeSettings.theme
            };

            state.canvas.elements.push(element);
            document.getElementById('canvas').appendChild(pre);

            pre.addEventListener('mousedown', (e) => {
                if (state.currentTool === 'select') {
                    selectElement(element);
                    e.stopPropagation();
                }
            });

            code.addEventListener('input', () => {
                applyCodeLanguage(pre, element.language);
                saveToHistory();
            });
            code.addEventListener('blur', saveToHistory); // Save on blur too

            selectElement(element);
            saveToHistory();
        }

        function applyCodeTheme(preElement, theme) {
            preElement.classList.remove('dark-theme', 'light-theme', 'monokai-theme');
            if (theme === 'light') {
                preElement.classList.add('light-theme');
            } else if (theme === 'monokai') {
                preElement.classList.add('monokai-theme');
            } else {
                preElement.classList.add('dark-theme'); // Default to dark
            }
        }

        function applyCodeLanguage(preElement, language) {
            const codeElement = preElement.querySelector('code');
            // Remove old language class
            const oldClasses = Array.from(codeElement.classList).filter(cls => cls.startsWith('language-'));
            oldClasses.forEach(cls => codeElement.classList.remove(cls));
            
            // Add new language class
            const newClass = `language-${language}`;
            codeElement.classList.add(newClass);
            
            // Highlight with Prism
            if (typeof Prism !== 'undefined') {
                Prism.highlightElement(codeElement);
            }
        }


        // --- Event Handlers ---
        function handleCanvasMouseDown(e) {
            if (e.button !== 0) return; // Only left mouse button
            const rect = e.currentTarget.getBoundingClientRect();
            const x = (e.clientX - rect.left) / state.canvas.zoom - state.canvas.panX / state.canvas.zoom;
            const y = (e.clientY - rect.top) / state.canvas.zoom - state.canvas.panY / state.canvas.zoom;
            state.startPoint = { x, y };

            if (state.isCreatingConnector) {
                // Check if clicking on another shape to end connector
                const clickedElement = getElementAtPosition(e.clientX, e.clientY);
                if (clickedElement && clickedElement.type === 'shape' && clickedElement.id !== state.connectorStartPoint.elementId) {
                    // Check if clicked on a connection point
                    const localX = x - clickedElement.x;
                    const localY = y - clickedElement.y;
                    let endPoint = null;
                    let minDist = Infinity;
                    clickedElement.connectionPoints.forEach(point => {
                        const dx = point.x - localX;
                        const dy = point.y - localY;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < minDist && dist < 20) {
                            minDist = dist;
                            endPoint = point;
                        }
                    });
                    if (endPoint) {
                        finishConnector(x, y, clickedElement, endPoint.id);
                    } else {
                        finishConnector(x, y); // End freely
                    }
                } else {
                    finishConnector(x, y); // End freely if not on a valid target
                }
                return;
            }

            switch(state.currentTool) {
                case 'select':
                    const clickedElement = getElementAtPosition(e.clientX, e.clientY);
                    if (clickedElement) {
                        selectElement(clickedElement);
                        startDragging(e, clickedElement);
                    } else {
                        deselectAll();
                    }
                    break;
                case 'brush':
                    startDrawing(x, y);
                    break;
                case 'eraser':
                    startErasing(x, y);
                    break;
                case 'text':
                    createTextElement(x, y);
                    break;
                case 'shape':
                    createShapeElement(x, y);
                    break;
                case 'connector':
                    // Handled by shape click or free placement if needed
                    break;
                case 'code':
                    createCodeElement(x, y);
                    break;
            }
        }

        function handleCanvasMouseMove(e) {
            const rect = e.currentTarget.getBoundingClientRect();
            const x = (e.clientX - rect.left) / state.canvas.zoom - state.canvas.panX / state.canvas.zoom;
            const y = (e.clientY - rect.top) / state.canvas.zoom - state.canvas.panY / state.canvas.zoom;

            if (state.isPanning && state.startPoint) {
                const dx = (x - state.startPoint.x) * state.canvas.zoom;
                const dy = (y - state.startPoint.y) * state.canvas.zoom;
                state.canvas.panX += dx;
                state.canvas.panY += dy;
                state.startPoint = { x, y }; // Update for next move
                updateCanvasTransform();
                return;
            }

            if (state.isDrawing && state.currentPath) {
                if (state.currentTool === 'brush') {
                    drawLine(state.startPoint.x, state.startPoint.y, x, y);
                } else if (state.currentTool === 'eraser') {
                    eraseLine(state.startPoint.x, state.startPoint.y, x, y);
                }
                state.startPoint = { x, y };
            }
            
            if (state.isCreatingConnector && state.tempConnector) {
                updateTempConnector(x, y);
            }
        }

        function handleCanvasMouseUp(e) {
            if (state.isDrawing) {
                state.isDrawing = false;
                if (state.currentPath) {
                    saveToHistory();
                    state.currentPath = null;
                }
            }
            if (state.isPanning) {
                state.isPanning = false;
                e.currentTarget.style.cursor = getCursorForTool(state.currentTool);
            }
            state.startPoint = null;
        }

        function handleCanvasWheel(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            zoom(delta, e.clientX, e.clientY);
        }

        // Basic touch support
        function handleCanvasTouchStart(e) {
             if (e.touches.length === 1) {
                const touch = e.touches[0];
                const rect = e.currentTarget.getBoundingClientRect();
                const x = (touch.clientX - rect.left) / state.canvas.zoom - state.canvas.panX / state.canvas.zoom;
                const y = (touch.clientY - rect.top) / state.canvas.zoom - state.canvas.panY / state.canvas.zoom;
                state.startPoint = { x, y };
                if (state.currentTool === 'brush') {
                    startDrawing(x, y);
                }
            } else if (e.touches.length === 2) {
                 // Simple two-finger pan start
                 state.isPanning = true;
                 const touch1 = e.touches[0];
                 const touch2 = e.touches[1];
                 const centerX = (touch1.clientX + touch2.clientX) / 2;
                 const centerY = (touch1.clientY + touch2.clientY) / 2;
                 const rect = e.currentTarget.getBoundingClientRect();
                 const x = (centerX - rect.left) / state.canvas.zoom - state.canvas.panX / state.canvas.zoom;
                 const y = (centerY - rect.top) / state.canvas.zoom - state.canvas.panY / state.canvas.zoom;
                 state.startPoint = { x, y };
            }
        }

        function handleCanvasTouchMove(e) {
            e.preventDefault(); // Prevent scrolling
            if (state.isPanning && e.touches.length === 2) {
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const centerX = (touch1.clientX + touch2.clientX) / 2;
                const centerY = (touch1.clientY + touch2.clientY) / 2;
                const rect = e.currentTarget.getBoundingClientRect();
                const x = (centerX - rect.left) / state.canvas.zoom - state.canvas.panX / state.canvas.zoom;
                const y = (centerY - rect.top) / state.canvas.zoom - state.canvas.panY / state.canvas.zoom;
                
                if(state.startPoint) {
                    const dx = (x - state.startPoint.x) * state.canvas.zoom;
                    const dy = (y - state.startPoint.y) * state.canvas.zoom;
                    state.canvas.panX += dx;
                    state.canvas.panY += dy;
                    updateCanvasTransform();
                }
                state.startPoint = { x, y };
            } else if (state.isDrawing && state.currentPath && e.touches.length === 1) {
                const touch = e.touches[0];
                const rect = e.currentTarget.getBoundingClientRect();
                const x = (touch.clientX - rect.left) / state.canvas.zoom - state.canvas.panX / state.canvas.zoom;
                const y = (touch.clientY - rect.top) / state.canvas.zoom - state.canvas.panY / state.canvas.zoom;
                if (state.currentTool === 'brush') {
                    drawLine(state.startPoint.x, state.startPoint.y, x, y);
                }
                state.startPoint = { x, y };
            }
        }

        function handleCanvasTouchEnd(e) {
             if (state.isDrawing) {
                state.isDrawing = false;
                if (state.currentPath) {
                    saveToHistory();
                    state.currentPath = null;
                }
            }
            state.isPanning = false;
            state.startPoint = null;
        }


        function getElementAtPosition(clientX, clientY) {
            const elements = [...document.elementsFromPoint(clientX, clientY)];
            for (const el of elements) {
                const canvasEl = state.canvas.elements.find(e => e.element === el || e.element.contains(el));
                if (canvasEl) {
                    return canvasEl;
                }
            }
            return null;
        }


        // --- Project Management ---
        function saveProjects() {
            try {
                localStorage.setItem('codecanvas_projects', JSON.stringify(state.projects));
                if(state.currentProject) {
                    localStorage.setItem('codecanvas_current', state.currentProject);
                }
            } catch(e) {
                console.error('Failed to save projects:', e);
                showNotification('Error saving projects.');
            }
        }

        function loadProjects() {
             // state.projects is loaded from localStorage in the state definition
             const currentId = localStorage.getItem('codecanvas_current');
             if (currentId && state.projects[currentId]) {
                 loadProject(currentId);
             } else if (Object.keys(state.projects).length > 0) {
                  // Load the first project if no current one
                  const firstProjectId = Object.keys(state.projects)[0];
                  loadProject(firstProjectId);
             } else {
                 createNewProject('Untitled Project');
             }
        }

        function createNewProject(name) {
            const projectId = 'project_' + Date.now();
            const project = {
                id: projectId,
                name: name || 'Untitled Project',
                created: new Date().toISOString(),
                modified: new Date().toISOString(),
                canvas: {
                    elements: [],
                    zoom: 1,
                    panX: 0,
                    panY: 0
                }
            };
            state.projects[projectId] = project;
            state.currentProject = projectId;
            loadProject(projectId); // This will clear and set up the new project
            saveProjects();
            return projectId;
        }

        function loadProject(projectId) {
            const project = state.projects[projectId];
            if (!project) return;

            // Clear current canvas
            state.canvas.elements.forEach(el => {
                 if (el.element && el.element.parentNode) {
                    el.element.parentNode.removeChild(el.element);
                }
            });
            state.canvas.elements = [];
            deselectAll();

            state.currentProject = projectId;
            document.getElementById('projectName').textContent = project.name;

            state.canvas.zoom = project.canvas.zoom || 1;
            state.canvas.panX = project.canvas.panX || 0;
            state.canvas.panY = project.canvas.panY || 0;
            updateCanvasTransform();
            updateZoomDisplay();

            // Restore elements
            if (project.canvas.elements) {
                // Use the robust restore function
                restoreSnapshot({elements: project.canvas.elements});
            }
        }

        function saveCurrentProject() {
            if (!state.currentProject) return;
            const project = state.projects[state.currentProject];
            if (!project) return;

            project.modified = new Date().toISOString();
            project.canvas = {
                elements: state.canvas.elements.map(el => {
                     let content = '';
                        if (el.type === 'text') {
                            content = el.element.value;
                        } else if (el.type === 'code') {
                            content = el.element.querySelector('code').textContent;
                        } else {
                            content = el.element.innerHTML;
                        }
                    return {
                        type: el.type,
                        id: el.id,
                        x: el.x,
                        y: el.y,
                        content: content,
                        style: el.element.getAttribute('style'),
                        attributes: getElementAttributes(el)
                    };
                }),
                zoom: state.canvas.zoom,
                panX: state.canvas.panX,
                panY: state.canvas.panY
            };

            saveProjects();
            showNotification('Project saved!');
        }

        function exportProject() {
            if (!state.currentProject) return;
            const project = state.projects[state.currentProject];
            if (!project) return;

            // Sanitize filename
            const filename = `${project.name.replace(/[^a-zA-Z0-9_\-.]/g, '_')}.codecanvas`;
            const dataStr = JSON.stringify(project, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link); // Required for Firefox
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            showNotification('Project exported!');
        }

        function importProject() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.codecanvas,.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const projectData = JSON.parse(e.target.result);
                        // Basic validation
                        if (!projectData.name || !projectData.id) {
                            throw new Error('Invalid project file structure.');
                        }
                        projectData.id = 'project_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9); // Generate new ID
                        projectData.created = projectData.created || new Date().toISOString();
                        projectData.modified = new Date().toISOString();
                        
                        state.projects[projectData.id] = projectData;
                        loadProject(projectData.id);
                        saveProjects();
                        showNotification('Project imported successfully!');
                    } catch(err) {
                        console.error('Import error:', err);
                        alert('Failed to import project: ' + (err.message || 'Invalid file format'));
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        function deleteProject(projectId) {
             if (confirm('Are you sure you want to delete this project? This cannot be undone.')) {
                delete state.projects[projectId];
                if (state.currentProject === projectId) {
                    state.currentProject = null;
                    // Clear canvas
                    state.canvas.elements.forEach(el => {
                         if (el.element && el.element.parentNode) {
                            el.element.parentNode.removeChild(el.element);
                        }
                    });
                    state.canvas.elements = [];
                    deselectAll();
                    document.getElementById('projectName').textContent = 'Untitled Project';
                    // Create a new default project
                    setTimeout(() => createNewProject('Untitled Project'), 10);
                }
                saveProjects();
                showProjectModal(); // Refresh the modal list
                showNotification('Project deleted.');
             }
        }

        // --- UI Functions ---
        function showNewProjectModal() {
            document.getElementById('newProjectModal').classList.add('active');
            document.getElementById('newProjectName').focus();
        }

        function showProjectModal() {
            const modal = document.getElementById('projectModal');
            const list = document.getElementById('projectList');
            list.innerHTML = '';

            if (Object.keys(state.projects).length === 0) {
                list.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-secondary);">No projects found.</div>';
            } else {
                Object.values(state.projects).sort((a, b) => new Date(b.modified) - new Date(a.modified)).forEach(project => {
                    const item = document.createElement('div');
                    item.className = 'project-item';
                    if (project.id === state.currentProject) {
                        item.classList.add('selected');
                    }
                    item.dataset.id = project.id;
                    item.innerHTML = `
                        <div>
                            <div>${project.name}</div>
                            <div class="project-date">Modified: ${new Date(project.modified).toLocaleString()}</div>
                        </div>
                        <div class="project-actions-cell">
                            <button class="project-action-btn delete-project-btn" title="Delete Project">&#x1F5D1;</button>
                        </div>
                    `;
                    item.addEventListener('click', (e) => {
                        if (e.target.classList.contains('delete-project-btn')) {
                             e.stopPropagation();
                             deleteProject(project.id);
                             return;
                        }
                        document.querySelectorAll('.project-item').forEach(i => i.classList.remove('selected'));
                        item.classList.add('selected');
                        // Add double-click to load
                        if (e.detail === 2) { // Double click
                            loadProject(project.id);
                            closeModal();
                        }
                    });
                    list.appendChild(item);
                });
            }
            modal.classList.add('active');
        }

        function closeModal() {
            document.querySelectorAll('.modal').forEach(modal => {
                modal.classList.remove('active');
            });
        }

        function showQuickActions() {
            alert('Quick actions menu would go here.');
        }


        // --- Initialization and Event Listeners ---
        function setupEventListeners() {
            // Tool buttons
            document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                btn.addEventListener('click', () => selectTool(btn.dataset.tool));
            });

            // Canvas interactions
            const canvas = document.getElementById('canvas');
            canvas.addEventListener('mousedown', handleCanvasMouseDown);
            canvas.addEventListener('mousemove', handleCanvasMouseMove);
            canvas.addEventListener('mouseup', handleCanvasMouseUp);
            canvas.addEventListener('mouseleave', handleCanvasMouseUp); // Treat mouse leave as mouse up
            canvas.addEventListener('wheel', handleCanvasWheel);
            
            // Touch support
            canvas.addEventListener('touchstart', handleCanvasTouchStart);
            canvas.addEventListener('touchmove', handleCanvasTouchMove);
            canvas.addEventListener('touchend', handleCanvasTouchEnd);

            // Zoom controls
            document.getElementById('zoomIn').addEventListener('click', () => zoom(1.2, window.innerWidth/2, window.innerHeight/2));
            document.getElementById('zoomOut').addEventListener('click', () => zoom(0.8, window.innerWidth/2, window.innerHeight/2));
            document.getElementById('zoomReset').addEventListener('click', resetZoom);

            // Project actions
            document.getElementById('newProjectBtn').addEventListener('click', showNewProjectModal);
            document.getElementById('openProjectBtn').addEventListener('click', showProjectModal);
            document.getElementById('saveProjectBtn').addEventListener('click', saveCurrentProject);
            document.getElementById('exportBtn').addEventListener('click', exportProject);
            document.getElementById('importBtn').addEventListener('click', importProject);

            // Grid toggle
            document.getElementById('gridToggle').addEventListener('click', toggleGrid);

            // Undo/Redo
            document.getElementById('undoBtn').addEventListener('click', undo);
            document.getElementById('redoBtn').addEventListener('click', redo);

            // Properties panel listeners
            document.getElementById('brushSize').addEventListener('input', (e) => {
                state.brushSettings.size = parseInt(e.target.value);
                document.getElementById('brushSizeValue').textContent = e.target.value;
            });
            document.getElementById('brushOpacity').addEventListener('input', (e) => {
                state.brushSettings.opacity = parseInt(e.target.value) / 100;
                document.getElementById('brushOpacityValue').textContent = e.target.value;
            });
            document.querySelectorAll('.color-swatch').forEach(swatch => {
                swatch.addEventListener('click', () => {
                    document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
                    swatch.classList.add('active');
                    state.brushSettings.color = swatch.dataset.color;
                });
            });

            document.getElementById('fontFamily').addEventListener('change', (e) => {
                state.textSettings.fontFamily = e.target.value;
                if (state.canvas.selectedElement && state.canvas.selectedElement.type === 'text') {
                    state.canvas.selectedElement.element.style.fontFamily = e.target.value;
                    saveToHistory();
                }
            });
            document.getElementById('fontSize').addEventListener('input', (e) => {
                state.textSettings.fontSize = parseInt(e.target.value);
                if (state.canvas.selectedElement && state.canvas.selectedElement.type === 'text') {
                    state.canvas.selectedElement.element.style.fontSize = e.target.value + 'px';
                    saveToHistory();
                }
            });
            document.getElementById('textColor').addEventListener('input', (e) => {
                state.textSettings.color = e.target.value;
                if (state.canvas.selectedElement && state.canvas.selectedElement.type === 'text') {
                    state.canvas.selectedElement.element.style.color = e.target.value;
                    saveToHistory();
                }
            });

            document.getElementById('shapeType').addEventListener('change', (e) => {
                state.shapeSettings.type = e.target.value;
            });
            document.getElementById('shapeFillColor').addEventListener('input', (e) => {
                state.shapeSettings.fillColor = e.target.value;
                if (state.canvas.selectedElement && state.canvas.selectedElement.type === 'shape') {
                    const shape = state.canvas.selectedElement.element.querySelector('.flowchart-shape');
                    if (shape) shape.setAttribute('fill', e.target.value);
                    saveToHistory();
                }
            });
            document.getElementById('shapeStrokeColor').addEventListener('input', (e) => {
                state.shapeSettings.strokeColor = e.target.value;
                if (state.canvas.selectedElement && state.canvas.selectedElement.type === 'shape') {
                    const shape = state.canvas.selectedElement.element.querySelector('.flowchart-shape');
                    if (shape) shape.setAttribute('stroke', e.target.value);
                    saveToHistory();
                }
            });
            document.getElementById('shapeStrokeWidth').addEventListener('input', (e) => {
                state.shapeSettings.strokeWidth = parseInt(e.target.value);
                if (state.canvas.selectedElement && state.canvas.selectedElement.type === 'shape') {
                    const shape = state.canvas.selectedElement.element.querySelector('.flowchart-shape');
                    if (shape) shape.setAttribute('stroke-width', e.target.value);
                    saveToHistory();
                }
            });
            
             document.getElementById('connectorStrokeColor').addEventListener('input', (e) => {
                state.connectorSettings.strokeColor = e.target.value;
                // Update selected connector if any
                if (state.canvas.selectedElement && state.canvas.selectedElement.type === 'connector') {
                    const path = state.canvas.selectedElement.element.querySelector('.connector-path');
                    if (path) {
                        path.setAttribute('stroke', e.target.value);
                        state.canvas.selectedElement.strokeColor = e.target.value;
                        saveToHistory();
                    }
                }
            });
            document.getElementById('connectorStrokeWidth').addEventListener('input', (e) => {
                state.connectorSettings.strokeWidth = parseInt(e.target.value);
                 if (state.canvas.selectedElement && state.canvas.selectedElement.type === 'connector') {
                    const path = state.canvas.selectedElement.element.querySelector('.connector-path');
                    if (path) {
                        path.setAttribute('stroke-width', e.target.value);
                        state.canvas.selectedElement.strokeWidth = parseInt(e.target.value);
                        saveToHistory();
                    }
                }
            });
            document.getElementById('connectorArrowheads').addEventListener('change', (e) => {
                state.connectorSettings.arrowheads = e.target.value;
                 if (state.canvas.selectedElement && state.canvas.selectedElement.type === 'connector') {
                    const path = state.canvas.selectedElement.element.querySelector('.connector-path');
                    if (path) {
                        path.removeAttribute('marker-start');
                        path.removeAttribute('marker-end');
                        if (e.target.value === 'end' || e.target.value === 'both') {
                            path.setAttribute('marker-end', 'url(#arrowhead)');
                        }
                        if (e.target.value === 'start' || e.target.value === 'both') {
                            path.setAttribute('marker-start', 'url(#arrowhead)');
                        }
                        state.canvas.selectedElement.arrowheads = e.target.value;
                        saveToHistory();
                    }
                }
            });

            document.getElementById('codeLanguage').addEventListener('change', (e) => {
                state.codeSettings.language = e.target.value;
                if (state.canvas.selectedElement && state.canvas.selectedElement.type === 'code') {
                    state.canvas.selectedElement.language = e.target.value;
                    applyCodeLanguage(state.canvas.selectedElement.element, e.target.value);
                    saveToHistory();
                }
            });
            document.getElementById('codeTheme').addEventListener('change', (e) => {
                state.codeSettings.theme = e.target.value;
                if (state.canvas.selectedElement && state.canvas.selectedElement.type === 'code') {
                    state.canvas.selectedElement.theme = e.target.value;
                    applyCodeTheme(state.canvas.selectedElement.element, e.target.value);
                    saveToHistory();
                }
            });

            document.getElementById('deleteElementBtn').addEventListener('click', deleteSelectedElement);
            document.getElementById('bringToFrontBtn').addEventListener('click', () => changeElementOrder('front'));
            document.getElementById('sendToBackBtn').addEventListener('click', () => changeElementOrder('back'));

            // FAB menu
            document.getElementById('fabMenu').addEventListener('click', showQuickActions);

            // Modal actions
            document.getElementById('createProjectBtn').addEventListener('click', () => {
                const name = document.getElementById('newProjectName').value.trim();
                if (name) {
                    createNewProject(name);
                    closeModal();
                }
            });
            document.getElementById('loadProjectBtn').addEventListener('click', () => {
                const selected = document.querySelector('.project-item.selected');
                if (selected) {
                    loadProject(selected.dataset.id);
                    closeModal();
                }
            });
            
            document.getElementById('cancelProjectBtn').addEventListener('click', closeModal);
            document.getElementById('cancelNewProjectBtn').addEventListener('click', closeModal);
            
            // Modal close buttons (X)
            document.querySelectorAll('.modal-close').forEach(btn => {
                btn.addEventListener('click', closeModal);
            });
            
            // Close modals if clicking outside content
            document.querySelectorAll('.modal').forEach(modal => {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) closeModal();
                });
            });

        }

        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Prevent default for keys that have actions
                const isCtrlCmd = e.ctrlKey || e.metaKey;
                
                if (!isCtrlCmd) {
                    switch(e.key.toLowerCase()) {
                        case 'v': selectTool('select'); e.preventDefault(); break;
                        case 'b': selectTool('brush'); e.preventDefault(); break;
                        case 'e': selectTool('eraser'); e.preventDefault(); break;
                        case 't': selectTool('text'); e.preventDefault(); break;
                        case 's': if(e.shiftKey) { selectTool('shape'); e.preventDefault(); } break; // Shift+S
                        case 'c': selectTool('connector'); e.preventDefault(); break;
                        case 'o': if(e.shiftKey) { showProjectModal(); e.preventDefault(); } break; // Shift+O
                    }
                }

                if (isCtrlCmd) {
                    if (e.key === 'z' && !e.shiftKey) {
                        e.preventDefault();
                        undo();
                    }
                    if ((e.key === 'y') || (e.key === 'z' && e.shiftKey)) {
                        e.preventDefault();
                        redo();
                    }
                    if (e.key === 's') {
                        e.preventDefault();
                        saveCurrentProject();
                    }
                    if (e.key === 'n') {
                        e.preventDefault();
                        showNewProjectModal();
                    }
                    if (e.key === 'o') {
                        e.preventDefault();
                        showProjectModal();
                    }
                    if (e.key === 'e') {
                        e.preventDefault();
                        exportProject();
                    }
                    if (e.key === 'i') {
                        e.preventDefault();
                        importProject();
                    }
                }

                if ((e.key === 'Delete' || e.key === 'Backspace') && state.canvas.selectedElement && document.activeElement.tagName !== 'TEXTAREA' && document.activeElement.tagName !== 'CODE') {
                    e.preventDefault();
                    deleteSelectedElement();
                }
                
                // Escape to deselect
                if (e.key === 'Escape') {
                    deselectAll();
                    // Also cancel connector creation
                    if (state.isCreatingConnector) {
                         state.isCreatingConnector = false;
                        state.connectorStartPoint = null;
                        if (state.tempConnector) {
                            state.tempConnector.remove();
                            state.tempConnector = null;
                        }
                    }
                }
            });
        }

        function initializeApp() {
            const canvas = document.getElementById('canvas');
            const container = document.querySelector('.canvas-container');
            
            // Center the canvas initially
            state.canvas.panX = (container.clientWidth - 5000) / 2;
            state.canvas.panY = (container.clientHeight - 5000) / 2;
            updateCanvasTransform();
            updateZoomDisplay();
            
            // Make canvas pannable with middle mouse button or Spacebar
            canvas.addEventListener('mousedown', (e) => {
                if (e.button === 1 || (e.button === 0 && e.shiftKey)) { // Middle mouse or Shift+Left
                    state.isPanning = true;
                    canvas.style.cursor = 'grabbing';
                    const rect = canvas.getBoundingClientRect();
                    const x = (e.clientX - rect.left) / state.canvas.zoom - state.canvas.panX / state.canvas.zoom;
                    const y = (e.clientY - rect.top) / state.canvas.zoom - state.canvas.panY / state.canvas.zoom;
                    state.startPoint = { x, y };
                    e.preventDefault();
                }
            });
            
            // Global key listener for panning toggle (Spacebar)
            let isSpacePanning = false;
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space' && !isSpacePanning) {
                    isSpacePanning = true;
                    canvas.style.cursor = 'grab'; // Indicate panning is ready
                }
            });
            document.addEventListener('keyup', (e) => {
                if (e.code === 'Space') {
                    isSpacePanning = false;
                    if (!state.isPanning) { // Only reset cursor if not actively panning
                        canvas.style.cursor = getCursorForTool(state.currentTool);
                    }
                }
            });
            canvas.addEventListener('mousemove', (e) => {
                if (isSpacePanning && e.buttons === 1) { // Spacebar held and mouse button down
                     if(!state.isPanning) {
                         state.isPanning = true;
                         canvas.style.cursor = 'grabbing';
                         const rect = canvas.getBoundingClientRect();
                         const x = (e.clientX - rect.left) / state.canvas.zoom - state.canvas.panX / state.canvas.zoom;
                         const y = (e.clientY - rect.top) / state.canvas.zoom - state.canvas.panY / state.canvas.zoom;
                         state.startPoint = { x, y };
                     }
                }
            });
            
        }

        // --- Main Execution ---
        document.addEventListener('DOMContentLoaded', () => {
            initializeApp();
            setupEventListeners();
            setupKeyboardShortcuts();
            loadProjects();
            
            // Autosave every 30 seconds
            setInterval(saveCurrentProject, 30000);
            
            showNotification('Welcome to CodeCanvas!');
        });
    </script>
    <!-- Embedded PrismJS Core and Languages -->
    <script>
    /* PrismJS 1.29.0
    https://prismjs.com/download.html#themes=prism-dark&languages=markup+css+clike+javascript+java+python+go+rust+swift+php+ruby+c+csharp+typescript+sql+yaml */
    var _self = "undefined" != typeof window ? window : "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope ? self : {}, Prism = function(e) {
    var n = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i, t = 0, r = {}, a = {
        manual: e.Prism && e.Prism.manual,
        disableWorkerMessageHandler: e.Prism && e.Prism.disableWorkerMessageHandler,
        util: {
            encode: function e(n) {
                return n instanceof i ? new i(n.type, e(n.content), n.alias) : Array.isArray(n) ? n.map(e) : n.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
            },
            type: function(e) {
                return Object.prototype.toString.call(e).slice(8, -1);
            },
            objId: function(e) {
                return e.__id || Object.defineProperty(e, "__id", {
                    value: ++t
                }), e.__id;
            },
            clone: function e(n, t) {
                var i, l;
                switch (t = t || {}, a.util.type(n)) {
                  case "Object":
                    if (l = a.util.objId(n), t[l]) return t[l];
                    for (var s in i = {}, t[l] = i, n) n.hasOwnProperty(s) && (i[s] = e(n[s], t));
                    return i;

                  case "Array":
                    return l = a.util.objId(n), t[l] ? t[l] : (i = [], t[l] = i, n.forEach((function(n, r) {
                        i[r] = e(n, t);
                    })), i);

                  default:
                    return n;
                }
            },
            getLanguage: function(e) {
                for (;e && !n.test(e.className); ) e = e.parentElement;
                return e ? (e.className.match(n) || [ , "none" ])[1].toLowerCase() : "none";
            },
            currentScript: function() {
                if ("undefined" == typeof document) return null;
                if ("currentScript" in document) return document.currentScript;
                try {
                    throw new Error();
                } catch (e) {
                    var n = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(e.stack) || [])[1];
                    if (n) {
                        var t = document.getElementsByTagName("script");
                        for (var r in t) if (t[r].src == n) return t[r];
                    }
                    return null;
                }
            },
            isActive: function(e, n, t) {
                for (var r = "no-" + n; e; ) {
                    var a = e.classList;
                    if (a.contains(n)) return !0;
                    if (a.contains(r)) return !1;
                    e = e.parentElement;
                }
                return !!t;
            }
        },
        languages: {
            plain: r,
            plaintext: r,
            text: r,
            txt: r,
            extend: function(e, n) {
                var t = a.util.clone(a.languages[e]);
                for (var r in n) t[r] = n[r];
                return t;
            },
            insertBefore: function(e, n, t, r) {
                var i = (r = r || a.languages)[e], l = {};
                for (var s in i) if (i.hasOwnProperty(s)) {
                    if (s == n) for (var o in t) t.hasOwnProperty(o) && (l[o] = t[o]);
                    t.hasOwnProperty(s) || (l[s] = i[s]);
                }
                var u = r[e];
                return r[e] = l, a.languages.DFS(a.languages, (function(n, t) {
                    t === u && n != e && (this[n] = l);
                })), l;
            },
            DFS: function e(n, t, r, i) {
                i = i || {};
                var l = a.util.objId;
                for (var s in n) if (n.hasOwnProperty(s)) {
                    t.call(n, s, n[s], r || s);
                    var o = n[s], u = a.util.type(o);
                    "Object" !== u || i[l(o)] ? "Array" !== u || i[l(o)] || (i[l(o)] = !0, e(o, t, s, i)) : (i[l(o)] = !0, 
                    e(o, t, null, i));
                }
            }
        },
        plugins: {},
        highlightAll: function(e, n) {
            a.highlightAllUnder(document, e, n);
        },
        highlightAllUnder: function(e, n, t) {
            var r = {
                callback: t,
                container: e,
                selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
            };
            a.hooks.run("before-highlightall", r), r.elements = Array.prototype.slice.apply(r.container.querySelectorAll(r.selector)), 
            a.hooks.run("before-all-elements-highlight", r);
            for (var i, l = 0; i = r.elements[l++]; ) a.highlightElement(i, !0 === n, r.callback);
        },
        highlightElement: function(n, t, r) {
            var i = a.util.getLanguage(n), l = a.languages[i];
            a.util.setLanguage(n, i);
            var s = n.parentElement;
            s && "pre" === s.nodeName.toLowerCase() && a.util.setLanguage(s, i);
            var o = {
                element: n,
                language: i,
                grammar: l,
                code: n.textContent || ""
            };
            function u(e) {
                o.highlightedCode = e, a.hooks.run("before-insert", o), o.element.innerHTML = o.highlightedCode, 
                a.hooks.run("after-highlight", o), a.hooks.run("complete", o), r && r.call(o.element);
            }
            if (a.hooks.run("before-sanity-check", o), (s = o.element.parentElement) && "pre" === s.nodeName.toLowerCase() && !s.hasAttribute("tabindex") && s.setAttribute("tabindex", "0"), 
            !o.code) return a.hooks.run("complete", o), void (r && r.call(o.element));
            if (a.hooks.run("before-highlight", o), o.grammar) if (t && e.Worker) {
                var c = new Worker(a.filename);
                c.onmessage = function(e) {
                    u(e.data);
                }, c.postMessage(JSON.stringify({
                    language: o.language,
                    code: o.code,
                    immediateClose: !0
                }));
            } else u(a.highlight(o.code, o.grammar, o.language)); else u(a.util.encode(o.code));
        },
        highlight: function(e, n, t) {
            var r = {
                code: e,
                grammar: n,
                language: t
            };
            if (a.hooks.run("before-tokenize", r), !r.grammar) throw new Error('The language "' + r.language + '" has no grammar.');
            return r.tokens = a.tokenize(r.code, r.grammar), a.hooks.run("after-tokenize", r), 
            i.stringify(a.util.encode(r.tokens), r.language);
        },
        tokenize: function(e, n) {
            var t = n.rest;
            if (t) {
                for (var r in t) n[r] = t[r];
                delete n.rest;
            }
            var a = new s();
            return u(a, a.head, e), o(e, a, n, a.head, 0), function(e) {
                for (var n = [], t = e.head.next; t !== e.tail; ) n.push(t.value), t = t.next;
                return n;
            }(a);
        },
        hooks: {
            all: {},
            add: function(e, n) {
                var t = a.hooks.all;
                t[e] = t[e] || [], t[e].push(n);
            },
            run: function(e, n) {
                var t = a.hooks.all[e];
                if (t && t.length) for (var r, i = 0; r = t[i++]; ) r(n);
            }
        },
        Token: i
    };
    function i(e, n, t, r) {
        this.type = e, this.content = n, this.alias = t, this.length = 0 | (r || "").length;
    }
    function l(e, n, t, r) {
        e.lastIndex = n;
        var a = e.exec(t);
        if (a && r && a[1]) {
            var i = a[1].length;
            a.index += i, a[0] = a[0].slice(i);
        }
        return a;
    }
    function s() {
        var e = {
            value: null,
            prev: null,
            next: null
        }, n = {
            value: null,
            prev: e,
            next: null
        };
        e.next = n, this.head = e, this.tail = n, this.length = 0;
    }
    function o(e, n, t, r, s, g) {
        for (var f in t) if (t.hasOwnProperty(f) && t[f]) {
            var h = t[f];
            h = Array.isArray(h) ? h : [h];
            for (var d = 0; d < h.length; ++d) {
                if (g && g.cause == f + "," + d) continue;
                var v = h[d], p = v.inside, m = !!v.lookbehind, y = !!v.greedy, k = v.alias;
                if (y && !v.pattern.global) {
                    var x = v.pattern.toString().match(/[imsuy]*$/)[0];
                    v.pattern = RegExp(v.pattern.source, x + "g");
                }
                for (var b = v.pattern || v, w = r.next, A = s; w !== n.tail && !(r.length > n.length); ) {
                    var E = w.value;
                    if (n.length > e.length) return;
                    if (!(E instanceof i)) {
                        var P, L = 1;
                        if (y) {
                            if (!(P = l(b, A, e, m)) || P.index >= e.length) break;
                            var S = P.index, O = P.index + P[0].length, j = A;
                            for (A += E.length; S >= A; ) j = (w = w.next).value, A += j.length;
                            if (A -= j.length, w.value instanceof i) continue;
                            for (var C = w; C !== n.tail && (A < O || "string" == typeof C.value); ) C = C.next;
                            L = n.length, u(n, w, C), w = n.tail;
                        } else if (!(P = l(b, 0, E, m))) continue;
                        var S = P.index, N = P[0], _ = E.slice(0, S), M = E.slice(S + N.length), W = A + E.length;
                        _( && (w.prev.next = new function(e, n) {
                            for (var t = n ? n.value : e.value; t instanceof i && "comment" !== t.type && "cdata" !== t.type; ) n ? (t = t.content).content && (t = t.content) : (t = t.content).content && (t = t.content);
                            return "string" == typeof t ? new i("comment", t) : t;
                        }(_, w.prev), w.prev = w.prev.next), M && (w.next = new function(e, n) {
                            for (var t = n ? n.value : e.value; t instanceof i && "comment" !== t.type && "cdata" !== t.type; ) n ? (t = t.content).content && (t = t.content) : (t = t.content).content && (t = t.content);
                            return "string" == typeof t ? new i("cdata", t) : t;
                        }(M, w), w.next.prev = w.next), L = 1;
                        var z = new i(f, p ? a.tokenize(N, p) : N, k, N);
                        if (w.prev.next = z, w.prev = z, N && z.length++, n.length -= L) {
                            var I = n.length;
                            for (o(e, n, t, w.prev, A, {
                                cause: f + "," + d,
                                reach: I
                            }); L > 0; ) w = w.next, L--;
                            if (n.length > I) {
                                var T = n.length - I;
                                for (r.length += T, L = T; L > 0; ) w = w.prev, L--;
                            }
                        }
                    }
                    w = w.next;
                }
            }
        }
    }
    function u(e, n, t) {
        var r, a, i = n.prev, l = t.next;
        i && i.next == l && (a = i).next = t, (r = n).prev = t.prev, t.prev = r, r.next = t, 
        e.length--, u(e, n, t), e.length++;
    }
    if (e.Prism = a, i.stringify = function e(n, t) {
        if ("string" == typeof n) return n;
        if (Array.isArray(n)) {
            var r = "";
            return n.forEach((function(n) {
                r += e(n, t);
            })), r;
        }
        var i = {
            type: n.type,
            content: e(n.content, t),
            tag: "span",
            classes: [ "token", n.type ],
            attributes: {},
            language: t
        }, l = n.alias;
        l && (Array.isArray(l) ? Array.prototype.push.apply(i.classes, l) : i.classes.push(l)), 
        a.hooks.run("wrap", i);
        var s = "";
        for (var o in i.attributes) s += " " + o + '="' + (i.attributes[o] || "").replace(/"/g, "&quot;") + '"';
        return "<" + i.tag + ' class="' + i.classes.join(" ") + '"' + s + ">" + i.content + "</" + i.tag + ">";
    }, !e.document) return e.addEventListener ? (a.disableWorkerMessageHandler || e.addEventListener("message", (function(n) {
        var t = JSON.parse(n.data), r = t.language, i = t.code, l = t.immediateClose;
        e.postMessage(a.highlight(i, a.languages[r], r)), l && e.close();
    }), !1), a) : a;
    var c = a.util.currentScript();
    function g() {
        a.manual || a.highlightAll();
    }
    return c && (a.filename = c.src, c.hasAttribute("data-manual") && (a.manual = !0)), 
    a.manual || ("loading" === document.readyState ? document.addEventListener("DOMContentLoaded", g) : window.requestAnimationFrame ? window.requestAnimationFrame(g) : window.setTimeout(g, 16)), 
    a;
}(_self);
"undefined" != typeof module && module.exports && (module.exports = Prism), "undefined" != typeof global && (global.Prism = Prism);
Prism.languages.markup = {
    comment: {
        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
        greedy: !0
    },
    prolog: {
        pattern: /<\?[\s\S]+?\?>/,
        greedy: !0
    },
    doctype: {
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: !0,
        inside: {
            "internal-subset": {
                pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
                lookbehind: !0,
                greedy: !0,
                inside: null
            },
            string: {
                pattern: /"[^"]*"|'[^']*'/,
                greedy: !0
            },
            punctuation: /^<!|>$|[[\]]/,
            "doctype-tag": /^DOCTYPE/i,
            name: /[^\s<>'"]+/
        }
    },
    cdata: {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        greedy: !0
    },
    tag: {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: !0,
        inside: {
            tag: {
                pattern: /^<\/?[^\s>\/]+/,
                inside: {
                    punctuation: /^<\/?/,
                    namespace: /^[^\s>\/:]+:/
                }
            },
            "special-attr": [],
            "attr-value": {
                pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
                inside: {
                    punctuation: [{
                        pattern: /^=/,
                        alias: "attr-equals"
                    }, {
                        pattern: /^(\s*)["']|["']$/,
                        lookbehind: !0
                    }]
                }
            },
            punctuation: /\/?>/,
            "attr-name": {
                pattern: /[^\s>\/]+/,
                inside: {
                    namespace: /^[^\s>\/:]+:/
                }
            }
        }
    },
    entity: [ {
        pattern: /&[\da-z]{1,8};/i,
        alias: "named-entity"
    }, /&#x?[\da-f]{1,8};/i ]
}, Prism.languages.markup.tag.inside["attr-value"].inside.entity = Prism.languages.markup.entity, 
Prism.languages.markup.doctype.inside["internal-subset"].inside = Prism.languages.markup, 
Prism.hooks.add("wrap", (function(e) {
    "entity" === e.type && (e.attributes.title = e.content.replace(/&amp;/, "&"));
})), Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
    value: function(e, n) {
        var t = {};
        t["language-" + n] = {
            pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
            lookbehind: !0,
            inside: Prism.languages[n]
        }, t.cdata = /^<!\[CDATA\[|\]\]>$/i;
        var r = {
            "included-cdata": {
                pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
                inside: t
            }
        };
        r["language-" + n] = {
            pattern: /[\s\S]+/,
            inside: Prism.languages[n]
        };
        var a = {};
        a[e] = {
            pattern: RegExp("(<__[^>]*>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[\\s\\S])*?(?=</__>)".replace(/__/g, (function() {
                return e;
            })), "i"),
            lookbehind: !0,
            greedy: !0,
            inside: r
        }, Prism.languages.insertBefore("markup", "cdata", a);
    }
}), Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
    value: function(e, n) {
        Prism.languages.markup.tag.inside["special-attr"].push({
            pattern: RegExp("(^|[\"'\\s])(?:" + e + ")\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))", "i"),
            lookbehind: !0,
            inside: {
                "attr-name": /^[^\s=]+/,
                "attr-value": {
                    pattern: /=[\s\S]+/,
                    inside: {
                        value: {
                            pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                            lookbehind: !0,
                            alias: [ n, "language-" + n ],
                            inside: Prism.languages[n]
                        },
                        punctuation: [{
                            pattern: /^=/,
                            alias: "attr-equals"
                        }, /"|'/]
                    }
                }
            }
        });
    }
}), Prism.languages.html = Prism.languages.markup, Prism.languages.mathml = Prism.languages.markup, 
Prism.languages.svg = Prism.languages.markup, Prism.languages.xml = Prism.languages.extend("markup", {}), 
Prism.languages.ssml = Prism.languages.xml, Prism.languages.atom = Prism.languages.xml, 
Prism.languages.rss = Prism.languages.xml;
Prism.languages.css = {
    comment: /\/\*[\s\S]*?\*\//,
    atrule: {
        pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
        inside: {
            rule: /^@[\w-]+/,
            "selector-function-argument": {
                pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
                lookbehind: !0,
                alias: "selector"
            },
            keyword: {
                pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
                lookbehind: !0
            }
        }
    },
    url: {
        pattern: RegExp("\\burl\\((?:[^\\\\r\\n()\"']|\\\\[\\s\\S]|(?:" + "(?:https?|ftp|file):)?//[^\\s\"'()]+(?:\\([^\\s\"'()]+\\)|[^\\s\"'()])" + "|\"(?:\\\\[^\\n\"\\\\r]|[^\\n\"\\\\\"])*\"|'(?:\\\\[^\\n'\\\\r]|[^\\n'\\\\'])*')\\)", "i"),
        greedy: !0,
        inside: {
            function: /^url/i,
            punctuation: /^\(|\)$/,
            string: {
                pattern: RegExp("^\"(?:\\\\[^\\n\"\\\\r]|[^\\n\"\\\\\"])*\"$|^'(?:\\\\[^\\n'\\\\r]|[^\\n'\\\\'])*'$"),
                inside: {
                    escape: /\\(?:\r\n|[\s\S])/
                }
            }
        }
    },
    selector: {
        pattern: RegExp("(^|[{}\\s])[^{}\\s](?:[^{};\"'\\s]|\\s+(?![\\s{])|\"(?:\\\\[^\\n\"\\\\r]|[^\\n\"\\\\\"])*\"|'(?:\\\\[^\\n'\\\\r]|[^\\n'\\\\'])*')*?(?=\\s*\\{)"),
        lookbehind: !0
    },
    string: {
        pattern: /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
    },
    property: {
        pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
        lookbehind: !0
    },
    important: /!important\b/i,
    function: {
        pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
        lookbehind: !0
    },
    punctuation: /[(){};:,]/
}, Prism.languages.css.atrule.inside.rest = Prism.languages.css;
var e = Prism.languages.markup;
e && (e.tag.addInlined("style", "css"), e.tag.addAttribute("style", "css"));
Prism.languages.clike = {
    comment: [{
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: !0,
        greedy: !0
    }, {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
    }],
    string: {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
    },
    "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: !0,
        inside: {
            punctuation: /[.\\]/
        }
    },
    keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    boolean: /\b(?:false|true)\b/,
    function: /\b\w+(?=\()/,
    number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    punctuation: /[{}[\];(),.:]/
};
Prism.languages.javascript = Prism.languages.extend("clike", {
    "class-name": [Prism.languages.clike["class-name"], {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
        lookbehind: !0
    }],
    keyword: [{
        pattern: /((?:^|\})\s*)catch\b/,
        lookbehind: !0
    }, {
        pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
        lookbehind: !0
    }],
    function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    number: {
        pattern: RegExp("(^|[^\\w$])(?:NaN|Infinity|0[bB][01]+(?:_[01]+)*n?|0[oO][0-7]+(?:_[0-7]+)*n?|0[xX][\\dA-Fa-f]+(?:_[\\dA-Fa-f]+)*n?|\\d+(?:_\\d+)*n|(?:\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\.\\d+(?:_\\d+)*)(?:[Ee][+-]?\\d+(?:_\\d+)*)?)(?![\\w$])"),
        lookbehind: !0
    },
    operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
}), Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, 
Prism.languages.insertBefore("javascript", "keyword", {
    regex: {
        pattern: RegExp("((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s]|\\b(?:return|yield))\\s*)/(?:(?:\\[(?:[^\\]\\\\\r\n]|\\\\.)*\\]|\\\\.|[^/\\\\\\[\r\n])+/[dgimyus]{0,7}|(?:\\[(?:[^[\\]\\\\\r\n]|\\\\.|\\[(?:[^[\\]\\\\\r\n]|\\\\.|\\[(?:[^[\\]\\\\\r\n]|\\\\.)*\\])*\\])*\\]|\\\\.|[^/\\\\\\[\r\n])+/[dgimyus]{0,7}v[dgimyus]{0,7})(?=(?:\\s|/\\*(?:[^*]|\\*(?!/))*\\*/)*(?:$|[\r\n,.;:})\\]]|//))"),
        lookbehind: !0,
        greedy: !0,
        inside: {
            "regex-source": {
                pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
                lookbehind: !0,
                alias: "language-regex",
                inside: Prism.languages.regex
            },
            "regex-delimiter": /^\/|\/$/,
            "regex-flags": /^[a-z]+$/
        }
    },
    "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
    },
    parameter: [ {
        pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
        lookbehind: !0,
        inside: Prism.languages.javascript
    }, {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
        lookbehind: !0,
        inside: Prism.languages.javascript
    }, {
        pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
        lookbehind: !0,
        inside: Prism.languages.javascript
    }, {
        pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
        lookbehind: !0,
        inside: Prism.languages.javascript
    } ],
    constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
}), Prism.languages.insertBefore("javascript", "string", {
    hashbang: {
        pattern: /^#!.*/,
        greedy: !0,
        alias: "comment"
    },
    "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: !0,
        inside: {
            "template-punctuation": {
                pattern: /^`|`$/,
                alias: "string"
            },
            interpolation: {
                pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
                lookbehind: !0,
                inside: {
                    "interpolation-punctuation": {
                        pattern: /^\$\{|\}$/,
                        alias: "punctuation"
                    },
                    rest: Prism.languages.javascript
                }
            },
            string: /[\s\S]+/
        }
    },
    "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: !0,
        greedy: !0,
        alias: "property"
    }
}), Prism.languages.insertBefore("javascript", "operator", {
    "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: !0,
        alias: "property"
    }
}), Prism.languages.markup && (Prism.languages.markup.tag.addInlined("script", "javascript"), 
Prism.languages.markup.tag.addAttribute("on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)", "javascript")), 
Prism.languages.js = Prism.languages.javascript;
Prism.languages.java = Prism.languages.extend("clike", {
    "class-name": [Prism.languages.clike["class-name"], {
        pattern: /(^|[^$\w.])(?!\s)[_$A-Z](?:(?!\s)[$\w])*(?=\s*\.\s*(?:[A-Z](?:[a-z]|\d)*(?:\.[A-Z](?:[a-z]|\d)*)*\.)*[A-Z](?:[a-z]|\d)*)/,
        lookbehind: !0,
        inside: {
            punctuation: /\./
        }
    }],
    keyword: /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?=\s*\()|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/,
    number: /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?[dfl]?/i,
    operator: {
        pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
        lookbehind: !0
    }
}), Prism.languages.insertBefore("java", "string", {
    "triple-quoted-string": {
        pattern: /"""[ \t]*[\r\n](?:.*[\r\n])*?[ \t]*"""/,
        greedy: !0,
        alias: "string"
    },
    "char": {
        pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
        greedy: !0
    }
}), Prism.languages.insertBefore("java", "class-name", {
    annotation: {
        pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
        lookbehind: !0,
        alias: "punctuation"
    },
    generics: {
        pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>/,
        inside: {
            "class-name": /\b[A-Z]\w*(?:\s*\.\s*[A-Z]\w*)*\b/,
            keyword: /\b(?:extends|super)\b/,
            punctuation: /[<>(),.:]/,
            operator: /[?&|]/
        }
    },
    import: [{
        pattern: /(\bimport\s+)static\s+[\w$.]+(?:\.[A-Z]\w*)?(?=\s*;)/,
        lookbehind: !0,
        alias: "static"
    }, {
        pattern: /(\bimport\s+)[\w$.]+(?:\.[A-Z]\w*)?(?=\s*;)/,
        lookbehind: !0,
        inside: {
            namespace: /\b\w+\.$/,
            punctuation: /\./
        }
    }],
    namespace: {
        pattern: /\b(?:module|open)\s+\w+\s*\.\s*[\w.]+/,
        inside: {
            punctuation: /\./
        }
    }
});
Prism.languages.python = {
    comment: {
        pattern: /(^|[^\\])#.*/,
        lookbehind: !0,
        greedy: !0
    },
    "string-interpolation": {
        pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
        greedy: !0,
        inside: {
            interpolation: {
                pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
                lookbehind: !0,
                inside: {
                    "format-spec": {
                        pattern: /(:)[^:(){}]+(?=\}$)/,
                        lookbehind: !0
                    },
                    "conversion-option": {
                        pattern: /![sra](?=[:}]$)/,
                        alias: "punctuation"
                    },
                    rest: null
                }
            },
            string: /[\s\S]+/
        }
    },
    "triple-quoted-string": {
        pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
        greedy: !0,
        alias: "string"
    },
    string: {
        pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
        greedy: !0
    },
    function: {
        pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
        lookbehind: !0
    },
    "class-name": {
        pattern: /(\bclass\s+)\w+/i,
        lookbehind: !0
    },
    decorator: {
        pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
        lookbehind: !0,
        alias: [ "annotation", "punctuation" ],
        inside: {
            punctuation: /\./
        }
    },
    keyword: /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
    builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
    boolean: /\b(?:False|None|True)\b/,
    number: /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
    operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
    punctuation: /[{}[\];(),.:]/
}, Prism.languages.python["string-interpolation"].inside.interpolation.inside.rest = Prism.languages.python, 
Prism.languages.py = Prism.languages.python;
Prism.languages.go = Prism.languages.extend("clike", {
    string: {
        pattern: /(["'`])(\\[\s\S]|(?!\1)[^\\])*\1/,
        greedy: !0
    },
    keyword: /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
    boolean: /\b(?:_|false|iota|nil|true)\b/,
    number: /(?:\b0x[a-f\d]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[-+]?\d+)?)i?/i,
    operator: /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
    builtin: /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|fmt|imag|index|int|int8|int16|int32|int64|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uint|uint8|uint16|uint32|uint64|uintptr)\b/
}), Prism.languages.insertBefore("go", "string", {
    char: {
        pattern: /'(?:\\(?:[abfnrtv\\']|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|U[0-9a-fA-F]{8})|[^\\'\r\n])'/,
        greedy: !0
    }
});
Prism.languages.rust = {
    comment: [{
        pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
        lookbehind: !0,
        greedy: !0
    }, {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
    }],
    string: {
        pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
        greedy: !0
    },
    char: {
        pattern: /b?'(?:\\(?:x[0-7][0-7]|u\{(?:[0-9a-fA-F]{1,6}_?)*\}|.)|[^\\\r\n\t'])'/,
        greedy: !0
    },
    "lifetime-annotation": {
        pattern: /'[^\s>']+/,
        alias: "symbol"
    },
    keyword: /\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|false|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|true|try|type|typeof|unsafe|unsized|use|virtual|where|while|yield)\b/,
    "function-definition": {
        pattern: /(\bfn\s+)\w+/,
        lookbehind: !0,
        alias: "function"
    },
    "type-definition": {
        pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
        lookbehind: !0,
        alias: "class-name"
    },
    "module-declaration": [ {
        pattern: /(\b(?:crate|mod)\s+)[a-z][a-zA-Z0-9_]*/,
        lookbehind: !0,
        alias: "namespace"
    }, {
        pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-zA-Z0-9_]*/,
        lookbehind: !0,
        alias: "namespace",
        inside: {
            punctuation: /::/
        }
    } ],
    "function-call": {
        pattern: /\b[a-z_]\w*(?=\s*(?:::\s*<\s*\w+\s*>)?\s*\()/i,
        alias: "function"
    },
    "macro-call": {
        pattern: /\b\w+!/,
        alias: "constant"
    },
    "type-parameter": {
        pattern: /<\s*\w+\s*>/,
        inside: {
            punctuation: /[<>]/
        }
    },
    "boolean": /\b(?:false|true)\b/,
    "number": /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|128|size)))?\b/,
    "function": /\b[a-z_]\w*(?=\s*(?:::\s*\w+\s*)?::\s*\w+\s*\()/i,
    "macro": {
        pattern: /\b\w+!/,
        alias: "property"
    },
    "constant": /\b[A-Z_][A-Z_\d]+\b/,
    "class-name": /\b[A-Z]\w*\b/,
    "namespace": {
        pattern: /\b(?:[a-z_]\w*::)+/,
        inside: {
            punctuation: /::/
        }
    },
    punctuation: /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
    operator: /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/
};
Prism.languages.swift = Prism.languages.extend("clike", {
    string: {
        pattern: /("|')(?:\\(?:\((?:[^()]|\([^)]+\))+\)|\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: !0,
        inside: {
            interpolation: {
                pattern: /\\\((?:[^()]|\([^)]+\))+\)/,
                inside: {
                    delimiter: {
                        pattern: /^\\\(|\)$/,
                        alias: "variable"
                    }
                }
            }
        }
    },
    keyword: /\b(?:as|associativity|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|dynamicType|else|enum|extension|fallthrough|final|for|func|get|guard|if|import|in|infix|init|inout|internal|is|lazy|left|let|mutating|new|none|nonmutating|operator|optional|override|postfix|precedence|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|Self|set|static|struct|subscript|super|switch|throw|throws|try|Type|typealias|unowned|unsafe|var|weak|where|while|willSet|__(?:COLUMN__|FILE__|FUNCTION__|LINE__))\b/,
    number: /\b(?:[\d_]+(?:\.[\d_]+)?(?:e[-+]?[\d_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?(?:p[-+]?[\d_]+)?|0o[0-7_]+|0b[01_]+)\b/i,
    constant: /\b(?:nil|true|false|__COLUMN__|__FILE__|__FUNCTION__|__LINE__)\b/,
    "atrule": /@\b(?:availability|autoclosure|noreturn|NSApplicationMain|NSCopying|NSManaged|objc|UIApplicationMain|IBAction|IBDesignable|IBInspectable|IBOutlet)\b/,
    "builtin": /\b(?:[A-Z]\w*)\b/,
    "class-name": {
        pattern: /\b[A-Z]\w*\b/,
        alias: "variable"
    },
    "function": /[a-z_]\w*(?=\s*\()/i
}), Prism.languages.insertBefore("swift", "operator", {
    "attribute": {
        pattern: /@\w+/,
        alias: "atrule"
    }
}), Prism.languages.insertBefore("swift", "string", {
    "literal": {
        pattern: /#"([^"]|"(?!"#))*"#/,
        greedy: !0
    }
});
Prism.languages.php = Prism.languages.extend("clike", {
    keyword: /\b(?:__halt_compiler|abstract|and|array|as|break|callable|case|catch|class|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|eval|exit|extends|final|finally|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|namespace|new|or|parent|print|private|protected|public|require|require_once|return|static|switch|throw|trait|try|unset|use|var|while|xor|yield)\b/i,
    "boolean": /\b(?:false|null|true)\b/i,
    "function": /\b\w+(?=\s*\()/,
    "number": /\b(?:0x[a-f\d]+|\d+\.?\d*(?:e[+-]?\d+)?)/i,
    "operator": {
        pattern: /(^|[^"\.])(?:\+[+=]?|-[-=>]?|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[!=]=?=?|[&|^]=?|~|\b(?:and|or|xor)\b)/,
        lookbehind: !0
    }
}), Prism.languages.insertBefore("php", "keyword", {
    delimiter: {
        pattern: /\?>|<\?(?:php|=)?/i,
        alias: "important"
    }
}), Prism.languages.insertBefore("php", "comment", {
    "comment": [{
        pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
        lookbehind: !0,
        greedy: !0
    }, {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
    }],
    "variable": /\$+(?:\w+\b|(?=\{))/
}), Prism.languages.insertBefore("php", "string", {
    "shell-comment": {
        pattern: /(^|[^\\])#.*/,
        lookbehind: !0,
        greedy: !0,
        alias: "comment"
    }
}), Prism.languages.insertBefore("php", "comment", {
    "delimiter": {
        pattern: /(^|[^\\])<<<'([^']+)'[\r\n](?:.*[\r\n])*?\2;/,
        lookbehind: !0,
        greedy: !0,
        alias: "comment",
        inside: {
            punctuation: /^<<<'[^']+'|[a-z_]\w*;$/i
        }
    }
}), Prism.languages.insertBefore("php", "string", {
    "shell-string": {
        pattern: /\$`(?:\\[\s\S]|[^\\`])*`/,
        greedy: !0,
        inside: {
            interpolation: {
                pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
                lookbehind: !0,
                inside: {
                    "interpolation-punctuation": {
                        pattern: /^\$\{|\}$/,
                        alias: "punctuation"
                    },
                    rest: Prism.languages.php
                }
            },
            variable: /\$+(?:\w+\b|(?=\{))/
        }
    }
}), Prism.languages.insertBefore("php", "string", {
    "nowdoc-string": {
        pattern: /<<<'([^']+)'[\r\n](?:.*[\r\n])*?\1;/,
        greedy: !0,
        alias: "string",
        inside: {
            punctuation: /^<<<'[^']+'|[a-z_]\w*;$/i
        }
    }
}), Prism.languages.insertBefore("php", "string", {
    "heredoc-string": {
        pattern: /<<<(?:"([^"]+)"[\r\n](?:.*[\r\n])*?\1;|([a-z_]\w*)[\r\n](?:.*[\r\n])*?\2;)/i,
        greedy: !0,
        alias: "string",
        inside: {
            interpolation: {
                pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
                lookbehind: !0,
                inside: {
                    "interpolation-punctuation": {
                        pattern: /^\$\{|\}$/,
                        alias: "punctuation"
                    },
                    rest: Prism.languages.php
                }
            },
            variable: /\$+(?:\w+\b|(?=\{))/,
            punctuation: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i
        }
    }
}), Prism.languages.insertBefore("php", "comment", {
    "delimiter": {
        pattern: /\?>|<\?(?:php|=)?/i,
        alias: "important"
    }
}), Prism.languages.insertBefore("php", "keyword", {
    "delimiter": {
        pattern: /(^|[^\\])<<<'([^']+)'[\r\n](?:.*[\r\n])*?\2;/,
        lookbehind: !0,
        greedy: !0,
        alias: "comment",
        inside: {
            punctuation: /^<<<'[^']+'|[a-z_]\w*;$/i
        }
    }
}), Prism.languages.insertBefore("php", "string", {
    "shell-comment": {
        pattern: /(^|[^\\])#.*/,
        lookbehind: !0,
        greedy: !0,
        alias: "comment"
    }
}), Prism.languages.insertBefore("php", "keyword", {
    "delimiter": {
        pattern: /\?>|<\?(?:php|=)?/i,
        alias: "important"
    }
});
Prism.languages.ruby = Prism.languages.extend("clike", {
    comment: [/#.*/, {
        pattern: /^=begin\s[\s\S]*?^=end/m,
        greedy: !0
    }],
    "class-name": {
        pattern: /(\b(?:class)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: !0,
        inside: {
            punctuation: /[.\\]/
        }
    },
    keyword: /\b(?:alias|and|BEGIN|begin|break|case|class|def|defined|do|else|elsif|END|end|ensure|false|for|if|in|module|new|next|nil|not|or|private|protected|public|raise|redo|require|rescue|retry|return|self|super|then|throw|true|undef|unless|until|when|while|yield)\b/
}), Prism.languages.insertBefore("ruby", "operator", {
    "double-colon": {
        pattern: /::/,
        alias: "punctuation"
    }
}), Prism.languages.insertBefore("ruby", "string", {
    "string": [ {
        pattern: /("|')(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|(?!\1)[^\\#\r\n])*\1/,
        greedy: !0,
        inside: {
            interpolation: {
                pattern: /#\{[^}]+\}/,
                inside: {
                    delimiter: {
                        pattern: /^#\{|\}$/,
                        alias: "variable"
                    },
                    rest: Prism.languages.ruby
                }
            },
            string: /[\s\S]+/
        }
    }, {
        pattern: /\b\w+\s*\/(?:[^\/\r\n\\]|\\.)+\//,
        greedy: !0,
        inside: {
            regex: {
                pattern: /^\/|\/[gim]*$/,
                alias: "operator"
            },
            string: /[\s\S]+/
        }
    } ]
}), Prism.languages.insertBefore("ruby", "comment", {
    "regex": [ {
        pattern: /%r([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1[gim]*/,
        greedy: !0,
        inside: {
            interpolation: {
                pattern: /#\{[^}]+\}/,
                inside: {
                    delimiter: {
                        pattern: /^#\{|\}$/,
                        alias: "variable"
                    },
                    rest: Prism.languages.ruby
                }
            },
            regex: {
                pattern: /(^%r.|.)[gim]*$/,
                lookbehind: !0,
                alias: "operator"
            },
            string: /[\s\S]+/
        }
    }, {
        pattern: /%r\((?:[^()\\]|\\[\s\S])*\)[gim]*/,
        greedy: !0,
        inside: {
            interpolation: {
                pattern: /#\{[^}]+\}/,
                inside: {
                    delimiter: {
                        pattern: /^#\{|\}$/,
                        alias: "variable"
                    },
                    rest: Prism.languages.ruby
                }
            },
            regex: {
                pattern: /(^%r.|.)[gim]*$/,
                lookbehind: !0,
                alias: "operator"
            },
            string: /[\s\S]+/
        }
    }, {
        pattern: /%r\{(?:[^{}\\]|\\[\s\S])*\}[gim]*/,
        greedy: !0,
        inside: {
            interpolation: {
                pattern: /#\{[^}]+\}/,
                inside: {
                    delimiter: {
                        pattern: /^#\{|\}$/,
                        alias: "variable"
                    },
                    rest: Prism.languages.ruby
                }
            },
            regex: {
                pattern: /(^%r.|.)[gim]*$/,
                lookbehind: !0,
                alias: "operator"
            },
            string: /[\s\S]+/
        }
    }, {
        pattern: /%r\[(?:[^\[\]\\]|\\[\s\S])*\][gim]*/,
        greedy: !0,
        inside: {
            interpolation: {
                pattern: /#\{[^}]+\}/,
                inside: {
                    delimiter: {
                        pattern: /^#\{|\}$/,
                        alias: "variable"
                    },
                    rest: Prism.languages.ruby
                }
            },
            regex: {
                pattern: /(^%r.|.)[gim]*$/,
                lookbehind: !0,
                alias: "operator"
            },
            string: /[\s\S]+/
        }
    }, {
        pattern: /%r<(?:[^<>\\]|\\[\s\S])*>[gim]*/,
        greedy: !0,
        inside: {
            interpolation: {
                pattern: /#\{[^}]+\}/,
                inside: {
                    delimiter: {
                        pattern: /^#\{|\}$/,
                        alias: "variable"
                    },
                    rest: Prism.languages.ruby
                }
            },
            regex: {
                pattern: /(^%r.|.)[gim]*$/,
                lookbehind: !0,
                alias: "operator"
            },
            string: /[\s\S]+/
        }
    } ]
}), Prism.languages.insertBefore("ruby", "string", {
    "symbol": {
        pattern: /:[a-zA-Z_]\w*(?:[?!](?![a-zA-Z_]\w*)?)?/,
        alias: "variable"
    }
});
Prism.languages.c = Prism.languages.extend("clike", {
    comment: [{
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: !0,
        greedy: !0
    }, {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
    }],
    string: {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
    },
    "class-name": {
        pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
        lookbehind: !0
    },
    keyword: /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
    function: /\b[a-z_]\w*(?=\s*\()/i,
    number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
    operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
}), Prism.languages.insertBefore("c", "string", {
    char: {
        pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
        greedy: !0
    }
}), Prism.languages.insertBefore("c", "string", {
    macro: {
        pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
        lookbehind: !0,
        greedy: !0,
        alias: "property",
        inside: {
            string: [{
                pattern: /^(#\s*include\s*)<[^>]+>/,
                lookbehind: !0
            }, Prism.languages.c.string],
            comment: Prism.languages.c.comment,
            "macro-name": [{
                pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
                lookbehind: !0
            }, {
                pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
                lookbehind: !0,
                alias: "function"
            }],
            directive: {
                pattern: /^(#\s*)[a-z]+/,
                lookbehind: !0,
                alias: "keyword"
            },
            "directive-hash": /^#/,
            punctuation: /##|\\(?=[\r\n])/,
            expression: {
                pattern: /\S[\s\S]*/,
                inside: Prism.languages.c
            }
        }
    },
    "constant": /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__VERSION__)\b/
});
delete Prism.languages.c["boolean"];
Prism.languages.typescript = Prism.languages.extend("javascript", {
    keyword: /\b(?:abstract|any|as|async|await|bigint|boolean|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|false|finally|for|from|function|get|globalThis|if|implements|import|in|infer|instanceof|interface|is|keyof|let|module|namespace|never|new|null|number|object|of|override|package|private|protected|public|readonly|require|return|set|static|string|super|switch|symbol|this|throw|true|try|type|typeof|undefined|unique|unknown|var|void|while|with|yield)\b/,
    builtin: /\b(?:Array|Boolean|console|Date|Error|Function|Intl|JSON|Math|Number|Object|Promise|RegExp|String|Symbol)\b/
}), Prism.languages.ts = Prism.languages.typescript;
    </script>
</body>
</html>


    
              <script>
                              
              </script>
                        </body>
                        </html>
                    
